// Generated by dts-bundle v0.7.3

declare module '@0b5vr/experimental' {
    export * from '@0b5vr/experimental/algorithm';
    export * from '@0b5vr/experimental/array';
    export * from '@0b5vr/experimental/CDS';
    export * from '@0b5vr/experimental/Clock';
    export * from '@0b5vr/experimental/color';
    export * from '@0b5vr/experimental/dag';
    export * from '@0b5vr/experimental/edt';
    export * from '@0b5vr/experimental/ExpSmooth';
    export * from '@0b5vr/experimental/GPUTimer';
    export * from '@0b5vr/experimental/HistoryMeanCalculator';
    export * from '@0b5vr/experimental/MapOfSet';
    export * from '@0b5vr/experimental/math';
    export * from '@0b5vr/experimental/midi';
    export * from '@0b5vr/experimental/poker';
    export * from '@0b5vr/experimental/Pool';
    export * from '@0b5vr/experimental/retry';
    export * from '@0b5vr/experimental/stniccc';
    export * from '@0b5vr/experimental/SmoothDamp';
    export * from '@0b5vr/experimental/Swap';
    export * from '@0b5vr/experimental/TapTempo';
    export * from '@0b5vr/experimental/tinyseq';
    export * from '@0b5vr/experimental/Xorshift';
    export * from '@0b5vr/experimental/yugop';
    export * from '@0b5vr/experimental/BinaryHeap';
    export * from '@0b5vr/experimental/notifyObservers';
}

declare module '@0b5vr/experimental/algorithm' {
    export * from '@0b5vr/experimental/algorithm/binarySearch';
    export * from '@0b5vr/experimental/algorithm/traverse';
}

declare module '@0b5vr/experimental/array' {
    export * from '@0b5vr/experimental/array/arrayRange';
    export * from '@0b5vr/experimental/array/arraySerial';
    export * from '@0b5vr/experimental/array/arraySet';
    export * from '@0b5vr/experimental/array/constants';
    export * from '@0b5vr/experimental/array/utils';
}

declare module '@0b5vr/experimental/CDS' {
    export * from '@0b5vr/experimental/CDS/CDS';
}

declare module '@0b5vr/experimental/Clock' {
    export * from '@0b5vr/experimental/Clock/Clock';
    export * from '@0b5vr/experimental/Clock/ClockFrame';
    export * from '@0b5vr/experimental/Clock/ClockRealtime';
}

declare module '@0b5vr/experimental/color' {
    export * from '@0b5vr/experimental/color/colorFromAtariST';
    export * from '@0b5vr/experimental/color/colorHSV2RGB';
    export * from '@0b5vr/experimental/color/colorToHex';
    export * from '@0b5vr/experimental/color/colorTurbo';
    export * from '@0b5vr/experimental/color/eotfRec709';
    export * from '@0b5vr/experimental/color/oetfRec709';
    export * from '@0b5vr/experimental/color/RawRGB';
}

declare module '@0b5vr/experimental/dag' {
    export * from '@0b5vr/experimental/dag/dagEdgesAncestors';
    export * from '@0b5vr/experimental/dag/dagEdgesChildren';
    export * from '@0b5vr/experimental/dag/dagEdgesDescendants';
    export * from '@0b5vr/experimental/dag/dagEdgesParent';
    export * from '@0b5vr/experimental/dag/dagEdgesParents';
    export * from '@0b5vr/experimental/dag/dagEdgesResolve';
    export * from '@0b5vr/experimental/dag/RawDagEdge';
}

declare module '@0b5vr/experimental/edt' {
    export { edt1d, edt2d } from '@0b5vr/experimental/edt/edt';
}

declare module '@0b5vr/experimental/ExpSmooth' {
    export * from '@0b5vr/experimental/ExpSmooth/ExpSmooth';
}

declare module '@0b5vr/experimental/GPUTimer' {
    export { GPUTimer } from '@0b5vr/experimental/GPUTimer/GPUTimer';
}

declare module '@0b5vr/experimental/HistoryMeanCalculator' {
    export * from '@0b5vr/experimental/HistoryMeanCalculator/HistoryMeanCalculator';
    export * from '@0b5vr/experimental/HistoryMeanCalculator/HistoryMedianCalculator';
    export * from '@0b5vr/experimental/HistoryMeanCalculator/HistoryPercentileCalculator';
}

declare module '@0b5vr/experimental/MapOfSet' {
    export * from '@0b5vr/experimental/MapOfSet/MapOfSet';
}

declare module '@0b5vr/experimental/math' {
    export * from '@0b5vr/experimental/math/box3';
    export * from '@0b5vr/experimental/math/euler';
    export * from '@0b5vr/experimental/math/line3';
    export * from '@0b5vr/experimental/math/mat2';
    export * from '@0b5vr/experimental/math/mat3';
    export * from '@0b5vr/experimental/math/mat4';
    export * from '@0b5vr/experimental/math/plane3';
    export * from '@0b5vr/experimental/math/quat';
    export * from '@0b5vr/experimental/math/ray3';
    export * from '@0b5vr/experimental/math/sphere3';
    export * from '@0b5vr/experimental/math/vec';
    export * from '@0b5vr/experimental/math/vec3';
    export * from '@0b5vr/experimental/math/vec4';
    export * from '@0b5vr/experimental/math/mod';
    export * from '@0b5vr/experimental/math/sanitizeAngle';
    export * from '@0b5vr/experimental/math/utils';
}

declare module '@0b5vr/experimental/midi' {
    export { midiParse } from '@0b5vr/experimental/midi/midiParse';
    export * from '@0b5vr/experimental/midi/MidiParseResult';
}

declare module '@0b5vr/experimental/poker' {
    export * from '@0b5vr/experimental/poker/createPokerDeck';
    export * from '@0b5vr/experimental/poker/evaluatePokerHand';
    export * from '@0b5vr/experimental/poker/PokerCard';
    export * from '@0b5vr/experimental/poker/PokerHand';
    export * from '@0b5vr/experimental/poker/pokerHandsByStrength';
    export * from '@0b5vr/experimental/poker/pokerHandStrengthMap';
    export * from '@0b5vr/experimental/poker/PokerRank';
    export * from '@0b5vr/experimental/poker/pokerRanksByStrength';
    export * from '@0b5vr/experimental/poker/pokerRankStrengthMap';
    export * from '@0b5vr/experimental/poker/PokerSuit';
    export * from '@0b5vr/experimental/poker/pokerSuitIndexMap';
    export * from '@0b5vr/experimental/poker/pokerSuitsByIndex';
    export * from '@0b5vr/experimental/poker/sortPokerCardsByRank';
}

declare module '@0b5vr/experimental/Pool' {
    export * from '@0b5vr/experimental/Pool/Pool';
}

declare module '@0b5vr/experimental/retry' {
    export * from '@0b5vr/experimental/retry/asyncRetry';
    export * from '@0b5vr/experimental/retry/retry';
}

declare module '@0b5vr/experimental/stniccc' {
    export * from '@0b5vr/experimental/stniccc/parseSTNICCC';
    export * from '@0b5vr/experimental/stniccc/STNICCCFrame';
    export * from '@0b5vr/experimental/stniccc/stnicccToSVG';
}

declare module '@0b5vr/experimental/SmoothDamp' {
    export * from '@0b5vr/experimental/SmoothDamp/SmoothDamp';
}

declare module '@0b5vr/experimental/Swap' {
    export * from '@0b5vr/experimental/Swap/Swap';
}

declare module '@0b5vr/experimental/TapTempo' {
    export * from '@0b5vr/experimental/TapTempo/TapTempo';
}

declare module '@0b5vr/experimental/tinyseq' {
    export { createTinyseqPolyReader } from '@0b5vr/experimental/tinyseq/createTinyseqPolyReader';
    export { createTinyseqReader } from '@0b5vr/experimental/tinyseq/createTinyseqReader';
    export { tinyseqFromMidiParseResult } from '@0b5vr/experimental/tinyseq/tinyseqFromMidiParseResult';
}

declare module '@0b5vr/experimental/Xorshift' {
    export * from '@0b5vr/experimental/Xorshift/Xorshift';
}

declare module '@0b5vr/experimental/yugop' {
    export { getYugopText } from '@0b5vr/experimental/yugop/getYugopText';
}

declare module '@0b5vr/experimental/BinaryHeap' {
    export class BinaryHeap<T> {
        readonly array: T[];
        readonly elementIndexMap: Map<T, number>;
        comparator: (a: T, b: T) => number;
        static defaultComparator(a: any, b: any): number;
        get length(): number;
        get isEmpty(): boolean;
        get root(): T;
        constructor(init?: T[], comparator?: (a: T, b: T) => number);
        push(...elements: T[]): void;
        pop(): T | null;
        delete(i: number): boolean;
        replace(i: number, rep: T): number | null;
    }
}

declare module '@0b5vr/experimental/notifyObservers' {
    /**
      * A bare function to notify observers.
      * The incredibly cheap implementation of the observer pattern.
      *
      * @example
      * ```ts
      * const observers = new Set<( text: string ) => void>();
      *
      * observers.add( ( text ) => console.log( text ) );
      * observers.add( ( text ) => alert( text ) );
      *
      * notifyObservers( observers, 'wenis' );
      * ```
      *
      * @param observers The iterator of observers
      * @param param The param you want to give to observers
      */
    export function notifyObservers(observers: Iterable<() => void>): void;
    export function notifyObservers<T>(observers: Iterable<(arg: T) => void>, param: T): void;
}

declare module '@0b5vr/experimental/algorithm/binarySearch' {
    /**
      * Look for an index from a sorted list using binary search.
      *
      * If you don't provide a compare function, it will look for **the first same value** it can find.
      * If it cannot find an exactly matching value, it can return N where the length of given array is N.
      *
      * @param array A sorted array
      * @param compare Make this function return `false` if you want to point right side of given element, `true` if you want to point left side of given element.
      * @returns An index found
      */
    export function binarySearch<T>(array: ArrayLike<T>, element: T): number;
    export function binarySearch<T>(array: ArrayLike<T>, compare: (element: T) => boolean): number;
}

declare module '@0b5vr/experimental/algorithm/traverse' {
    /**
      * Generic traverse function.
      *
      * It performs Depth-First Search.
      *
      * The `traverser` function will be executed for each descendants.
      * You need to return their "children" in an array.
      * If you want to stop the traversal, return `false` instead.
      *
      * @example
      * ```js
      * // replicate Three.js traverse for no reason
      * const meshes = [];
      * traverse( object3DRoot, ( object ) => {
      *   if ( object.isMesh ) {
      *     meshes.push( object );
      *   }
      *   return object3DRoot.children;
      * } );
      * ```
      *
      * @param root The "root" node
      * @param traverser The traverse function. If the node has "children" return them in an array.
      */
    export function traverse<TNode>(root: TNode, traverser: (node: TNode) => TNode[] | false): void;
}

declare module '@0b5vr/experimental/array/arrayRange' {
    export function arrayRange(start: number, end: number, step?: number): number[];
}

declare module '@0b5vr/experimental/array/arraySerial' {
    export const arraySerial: (count: number) => number[];
}

declare module '@0b5vr/experimental/array/arraySet' {
    export function arraySetDelete<T>(array: Array<T>, value: T): boolean;
    export function arraySetHas<T>(array: Array<T>, value: T): boolean;
    export function arraySetAdd<T>(array: Array<T>, value: T): boolean;
    export function arraySetUnion<T>(a: Array<T>, b: Array<T>): Array<T>;
    export function arraySetDiff<T>(from: Array<T>, diff: Array<T>): Array<T>;
}

declare module '@0b5vr/experimental/array/constants' {
    /**
        * `[ -1, -1, 1, -1, -1, 1, 1, 1 ]`
        */
    export const TRIANGLE_STRIP_QUAD: number[];
    /**
        * `[ -1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0 ]`
        */
    export const TRIANGLE_STRIP_QUAD_3D: number[];
    /**
        * `[ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]`
        */
    export const TRIANGLE_STRIP_QUAD_NORMAL: number[];
    /**
        * `[ 0, 0, 1, 0, 0, 1, 1, 1 ]`
        */
    export const TRIANGLE_STRIP_QUAD_UV: number[];
}

declare module '@0b5vr/experimental/array/utils' {
    /**
        * Shuffle given `array` using given `dice` RNG. **Destructive**.
        */
    export function shuffleArray<T>(array: T[], dice?: () => number): T[];
    /**
        * I like wireframe
        *
        * `triIndexToLineIndex( [ 0, 1, 2, 5, 6, 7 ] )` -> `[ 0, 1, 1, 2, 2, 0, 5, 6, 6, 7, 7, 5 ]`
        */
    export function triIndexToLineIndex<T>(array: T[]): T[];
    /**
        * `matrix2d( 3, 2 )` -> `[ 0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2 ]`
        */
    export function matrix2d(w: number, h: number): number[];
    /**
        * See also: {@link matrix2d}
        */
    export function matrix3d(w: number, h: number, d: number): number[];
}

declare module '@0b5vr/experimental/CDS/CDS' {
    /**
      * Critically Damped Spring
      *
      * Shoutouts to Keijiro Takahashi
      */
    export class CDS {
        factor: number;
        ratio: number;
        velocity: number;
        value: number;
        target: number;
        update(deltaTime: number): number;
    }
}

declare module '@0b5vr/experimental/Clock/Clock' {
    /**
        * Class that deals with time.
        * In this base class, you need to set time manually from `Automaton.update()`.
        * Best for sync with external clock stuff.
        */
    export class Clock {
            /**
                * Its current time.
                */
            protected __time: number;
            /**
                * Its deltaTime of last update.
                */
            protected __deltaTime: number;
            /**
                * Whether its currently playing or not.
                */
            protected __isPlaying: boolean;
            /**
                * Its current time.
                */
            get time(): number;
            /**
                * Its deltaTime of last update.
                */
            get deltaTime(): number;
            /**
                * Whether its currently playing or not.
                */
            get isPlaying(): boolean;
            /**
                * Update the clock.
                * @param time Time. You need to set manually when you are using manual Clock
                */
            update(time?: number): void;
            /**
                * Start the clock.
                */
            play(): void;
            /**
                * Stop the clock.
                */
            pause(): void;
            /**
                * Set the time manually.
                * @param time Time
                */
            setTime(time: number): void;
    }
}

declare module '@0b5vr/experimental/Clock/ClockFrame' {
    import { Clock } from '@0b5vr/experimental/Clock/Clock';
    /**
        * Class that deals with time.
        * This is "frame" type clock, the frame increases every {@link ClockFrame#update} call.
        * @param fps Frames per second
        */
    export class ClockFrame extends Clock {
            constructor(fps?: number);
            /**
                * Its current frame.
                */
            get frame(): number;
            /**
                * Its fps.
                */
            get fps(): number;
            /**
                * Update the clock. It will increase the frame by 1.
                */
            update(): void;
            /**
                * Set the time manually.
                * The set time will be converted into internal frame count, so the time will not be exactly same as set one.
                * @param time Time
                */
            setTime(time: number): void;
    }
}

declare module '@0b5vr/experimental/Clock/ClockRealtime' {
    import { Clock } from '@0b5vr/experimental/Clock/Clock';
    /**
        * Class that deals with time.
        * This is "realtime" type clock, the time goes on as real world.
        */
    export class ClockRealtime extends Clock {
            /**
                * The clock is realtime. yeah.
                */
            get isRealtime(): boolean;
            /**
                * Update the clock. Time is calculated based on time in real world.
                */
            update(): void;
            /**
                * Set the time manually.
                * @param time Time
                */
            setTime(time: number): void;
    }
}

declare module '@0b5vr/experimental/color/colorFromAtariST' {
    import type { RawRGB } from '@0b5vr/experimental/color/RawRGB';
    /**
      * Converts the input color in Atari-ST color palette format to a {@link RawRGB}.
      *
      * @param stColor A color in Atari-ST format
      */
    export function colorFromAtariST(stColor: number): RawRGB;
}

declare module '@0b5vr/experimental/color/colorHSV2RGB' {
    import { RawRGB } from '@0b5vr/experimental/color/RawRGB';
    /**
      * Convert a color from HSV to RGB.
      * Each component of the HSV must be given in [0 - 1] range.
      *
      * Ref: https://en.wikipedia.org/wiki/HSV_color_space
      */
    export function colorHSV2RGB([h, s, v]: [number, number, number]): RawRGB;
}

declare module '@0b5vr/experimental/color/colorToHex' {
    import type { RawRGB } from '@0b5vr/experimental/color/RawRGB';
    /**
      * Converts the input color to hex representation (e.g. #7f7f7f)
      * @param color color in {@link RawRGB}
      */
    export function colorToHex(color: RawRGB): string;
}

declare module '@0b5vr/experimental/color/colorTurbo' {
    import { RawRGB } from '@0b5vr/experimental/color/RawRGB';
    /**
        * Generate a turbo gradient.
        *
        * Ref: https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7
        */
    export function colorTurbo(x: number): RawRGB;
}

declare module '@0b5vr/experimental/color/eotfRec709' {
    import type { RawRGB } from '@0b5vr/experimental/color/RawRGB';
    /**
      * EOTF of Rec.709 a.k.a. sRGB-to-Linear
      */
    export function eotfRec709(value: RawRGB): RawRGB;
}

declare module '@0b5vr/experimental/color/oetfRec709' {
    import type { RawRGB } from '@0b5vr/experimental/color/RawRGB';
    /**
      * OETF of Rec.709 a.k.a. Linear-to-sRGB
      */
    export function oetfRec709(luminance: RawRGB): RawRGB;
}

declare module '@0b5vr/experimental/color/RawRGB' {
    export type RawRGB = [number, number, number];
}

declare module '@0b5vr/experimental/dag/dagEdgesAncestors' {
    import type { RawDagEdge } from '@0b5vr/experimental/dag/RawDagEdge';
    /**
      * Return all ancestor sources the specified destination has.
      * @param edges An array of dag edge
      * @param destination The target destination
      *
      * See also: {@link dagEdgesChildren}
      */
    export function dagEdgesAncestors<T>(edges: RawDagEdge<T>[], destination: T): T[];
}

declare module '@0b5vr/experimental/dag/dagEdgesChildren' {
    import { RawDagEdge } from '@0b5vr/experimental/dag/RawDagEdge';
    /**
      * Return all children destinations the specified source has.
      * @param edges An array of dag edge
      * @param source The target source
      *
      * See also: {@link dagEdgesDescendant}
      */
    export function dagEdgesChildren<T>(edges: RawDagEdge<T>[], source: T): T[];
}

declare module '@0b5vr/experimental/dag/dagEdgesDescendants' {
    import type { RawDagEdge } from '@0b5vr/experimental/dag/RawDagEdge';
    /**
      * Return all descendant destinations the specified source has.
      * @param edges An array of dag edge
      * @param source The target source
      *
      * See also: {@link dagEdgesChildren}
      */
    export function dagEdgesDescendants<T>(edges: RawDagEdge<T>[], source: T): T[];
}

declare module '@0b5vr/experimental/dag/dagEdgesParent' {
    import { RawDagEdge } from '@0b5vr/experimental/dag/RawDagEdge';
    /**
      * Return first parent source the specified destination has.
      * If it can't find a parent, it will return `null` instead.
      *
      * @param edges An array of dag edge
      * @param destination The target destination
      *
      * See also: {@link dagEdgesParents}
      */
    export function dagEdgesParent<T>(edges: RawDagEdge<T>[], destination: T): T | null;
}

declare module '@0b5vr/experimental/dag/dagEdgesParents' {
    import { RawDagEdge } from '@0b5vr/experimental/dag/RawDagEdge';
    /**
      * Return all parent sources the specified destination has.
      * @param edges An array of dag edge
      * @param destination The target destination
      *
      * See also: {@link dagEdgesChildren}
      */
    export function dagEdgesParents<T>(edges: RawDagEdge<T>[], destination: T): T[];
}

declare module '@0b5vr/experimental/dag/dagEdgesResolve' {
    import { RawDagEdge } from '@0b5vr/experimental/dag/RawDagEdge';
    /**
      * Resolve dag dependency relationship and give you a correct order.
      *
      * @param edges An array of dag edges
      * @param nodes An array of dag nodes
      */
    export function dagEdgesResolve<T>(edges: RawDagEdge<T>[], nodes: T[]): T[];
}

declare module '@0b5vr/experimental/dag/RawDagEdge' {
    export type RawDagEdge<T> = [T, T];
}

declare module '@0b5vr/experimental/edt/edt' {
    /**
        * Compute a one dimensional edt from the source data.
        * Returning distance will be squared.
        * Intended to be used internally in {@link edt2d}.
        *
        * @param data Data of the source
        * @param offset Offset of the source from beginning
        * @param stride Stride of the source
        * @param length Length of the source
        */
    export function edt1d(data: Float32Array, offset: number, stride: number, length: number): void;
    /**
        * Compute a two dimensional edt from the source data.
        * Returning distance will be squared.
        *
        * @param data Data of the source.
        * @param width Width of the source.
        * @param height Height of the source.
        */
    export function edt2d(data: Float32Array, width: number, height: number): void;
}

declare module '@0b5vr/experimental/ExpSmooth/ExpSmooth' {
    /**
      * Do exp smoothing
      */
    export class ExpSmooth {
        factor: number;
        target: number;
        value: number;
        update(deltaTime: number): number;
    }
}

declare module '@0b5vr/experimental/GPUTimer/GPUTimer' {
    import { Pool } from '@0b5vr/experimental/Pool/Pool';
    export class GPUTimer {
        queries: Pool<WebGLQuery>;
        stack: Promise<number>[];
        ext: any;
        readonly gl: WebGL2RenderingContext;
        static isSupported(gl: WebGLRenderingContext | WebGL2RenderingContext): boolean;
        constructor(gl: WebGL2RenderingContext);
        update(): void;
        measure(func: () => void): Promise<number>;
        check(query: WebGLQuery): Promise<number>;
    }
}

declare module '@0b5vr/experimental/HistoryMeanCalculator/HistoryMeanCalculator' {
    /**
      * Useful for tap tempo
      * See also: {@link HistoryMeanCalculator}
      */
    export class HistoryMeanCalculator {
        constructor(length: number);
        get mean(): number;
        get recalcForEach(): number;
        set recalcForEach(value: number);
        reset(): void;
        push(value: number): void;
        recalc(): void;
    }
}

declare module '@0b5vr/experimental/HistoryMeanCalculator/HistoryMedianCalculator' {
    import { HistoryPercentileCalculator } from '@0b5vr/experimental/HistoryMeanCalculator/HistoryPercentileCalculator';
    /**
      * @deprecated It's actually just a special case of {@link HistoryPercentileCalculator}
      */
    export class HistoryMedianCalculator extends HistoryPercentileCalculator {
        constructor(length: number);
    }
}

declare module '@0b5vr/experimental/HistoryMeanCalculator/HistoryPercentileCalculator' {
    /**
      * Useful for fps calc
      * See also: {@link HistoryMeanCalculator}
      */
    export class HistoryPercentileCalculator {
        constructor(length: number);
        get median(): number;
        percentile(percentile: number): number;
        reset(): void;
        push(value: number): void;
    }
}

declare module '@0b5vr/experimental/MapOfSet/MapOfSet' {
    export class MapOfSet<K, V> {
        readonly map: Map<K, Set<V>>;
        constructor();
        get(key: K): Set<V>;
        add(key: K, value: V): void;
    }
}

declare module '@0b5vr/experimental/math/box3' {
    export * from '@0b5vr/experimental/math/box3/Box3';
    export * from '@0b5vr/experimental/math/box3/box3ContainsPoint';
    export * from '@0b5vr/experimental/math/box3/RawBox3';
}

declare module '@0b5vr/experimental/math/euler' {
    export * from '@0b5vr/experimental/math/euler/Euler';
    export * from '@0b5vr/experimental/math/euler/eulerFromMat3';
    export * from '@0b5vr/experimental/math/euler/eulerFromMat4';
    export * from '@0b5vr/experimental/math/euler/eulerFromQuaternion';
    export * from '@0b5vr/experimental/math/euler/EulerOrder';
}

declare module '@0b5vr/experimental/math/line3' {
    export * from '@0b5vr/experimental/math/line3/Line3';
    export * from '@0b5vr/experimental/math/line3/line3ApplyMatrix4';
    export * from '@0b5vr/experimental/math/line3/line3At';
    export * from '@0b5vr/experimental/math/line3/line3ClosestPointToPoint';
    export * from '@0b5vr/experimental/math/line3/line3Delta';
    export * from '@0b5vr/experimental/math/line3/line3DistanceToPoint';
    export * from '@0b5vr/experimental/math/line3/RawLine3';
}

declare module '@0b5vr/experimental/math/mat2' {
    export { mat2Determinant } from '@0b5vr/experimental/math/mat2/mat2Determinant';
    export { mat2Inverse } from '@0b5vr/experimental/math/mat2/mat2Inverse';
    export { mat2Multiply } from '@0b5vr/experimental/math/mat2/mat2Multiply';
    export { mat2Transpose } from '@0b5vr/experimental/math/mat2/mat2Transpose';
    export { Matrix2 } from '@0b5vr/experimental/math/mat2/Matrix2';
    export type { RawMatrix2 } from '@0b5vr/experimental/math/mat2/RawMatrix2';
}

declare module '@0b5vr/experimental/math/mat3' {
    export { mat3CreateNormalMatrix } from '@0b5vr/experimental/math/mat3/mat3CreateNormalMatrix';
    export { mat3Determinant } from '@0b5vr/experimental/math/mat3/mat3Determinant';
    export { mat3FromMat4 } from '@0b5vr/experimental/math/mat3/mat3FromMat4';
    export { mat3FromMat4Transpose } from '@0b5vr/experimental/math/mat3/mat3FromMat4Transpose';
    export { mat3FromQuaternion } from '@0b5vr/experimental/math/mat3/mat3FromQuaternion';
    export { mat3Inverse } from '@0b5vr/experimental/math/mat3/mat3Inverse';
    export { mat3Multiply } from '@0b5vr/experimental/math/mat3/mat3Multiply';
    export { mat3Transpose } from '@0b5vr/experimental/math/mat3/mat3Transpose';
    export { Matrix3 } from '@0b5vr/experimental/math/mat3/Matrix3';
    export type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
}

declare module '@0b5vr/experimental/math/mat4' {
    export { mat4Compose } from '@0b5vr/experimental/math/mat4/mat4Compose';
    export { mat4Decompose } from '@0b5vr/experimental/math/mat4/mat4Decompose';
    export { mat4Determinant } from '@0b5vr/experimental/math/mat4/mat4Determinant';
    export { mat4FromMat3 } from '@0b5vr/experimental/math/mat4/mat4FromMat3';
    export { mat4FromQuaternion } from '@0b5vr/experimental/math/mat4/mat4FromQuaternion';
    export { mat4Inverse } from '@0b5vr/experimental/math/mat4/mat4Inverse';
    export { mat4LookAt } from '@0b5vr/experimental/math/mat4/mat4LookAt';
    export { mat4LookAtInverse } from '@0b5vr/experimental/math/mat4/mat4LookAtInverse';
    export { mat4Multiply } from '@0b5vr/experimental/math/mat4/mat4Multiply';
    export { mat4Perspective } from '@0b5vr/experimental/math/mat4/mat4Perspective';
    export { mat4RotationX } from '@0b5vr/experimental/math/mat4/mat4RotationX';
    export { mat4RotationY } from '@0b5vr/experimental/math/mat4/mat4RotationY';
    export { mat4RotationZ } from '@0b5vr/experimental/math/mat4/mat4RotationZ';
    export { mat4Scale } from '@0b5vr/experimental/math/mat4/mat4Scale';
    export { mat4ScaleScalar } from '@0b5vr/experimental/math/mat4/mat4ScaleScalar';
    export { mat4Translate } from '@0b5vr/experimental/math/mat4/mat4Translate';
    export { mat4Transpose } from '@0b5vr/experimental/math/mat4/mat4Transpose';
    export { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    export type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
}

declare module '@0b5vr/experimental/math/plane3' {
    export * from '@0b5vr/experimental/math/plane3/Plane3';
    export * from '@0b5vr/experimental/math/plane3/plane3ApplyMatrix4';
    export * from '@0b5vr/experimental/math/plane3/plane3DistanceToPoint';
    export * from '@0b5vr/experimental/math/plane3/plane3Normalize';
    export * from '@0b5vr/experimental/math/plane3/Planes3';
    export * from '@0b5vr/experimental/math/plane3/planes3ContainPoint';
    export * from '@0b5vr/experimental/math/plane3/planes3FromBox3';
    export * from '@0b5vr/experimental/math/plane3/planes3FromProjectionMatrix';
    export * from '@0b5vr/experimental/math/plane3/planes3IntersectBox3';
    export * from '@0b5vr/experimental/math/plane3/planes3IntersectSphere3';
    export * from '@0b5vr/experimental/math/plane3/RawPlane3';
}

declare module '@0b5vr/experimental/math/quat' {
    export { Quaternion } from '@0b5vr/experimental/math/quat/Quaternion';
    export { quatFromAxisAngle } from '@0b5vr/experimental/math/quat/quatFromAxisAngle';
    export { quatFromEuler } from '@0b5vr/experimental/math/quat/quatFromEuler';
    export { quatFromMatrix3 } from '@0b5vr/experimental/math/quat/quatFromMatrix3';
    export { quatFromMatrix4 } from '@0b5vr/experimental/math/quat/quatFromMatrix4';
    export { quatInverse } from '@0b5vr/experimental/math/quat/quatInverse';
    export { quatMultiply } from '@0b5vr/experimental/math/quat/quatMultiply';
    export { quatNormalize } from '@0b5vr/experimental/math/quat/quatNormalize';
    export { quatRotationX } from '@0b5vr/experimental/math/quat/quatRotationX';
    export { quatRotationY } from '@0b5vr/experimental/math/quat/quatRotationY';
    export { quatRotationZ } from '@0b5vr/experimental/math/quat/quatRotationZ';
    export type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
}

declare module '@0b5vr/experimental/math/ray3' {
    export * from '@0b5vr/experimental/math/ray3/RawRay3';
    export * from '@0b5vr/experimental/math/ray3/Ray3';
    export * from '@0b5vr/experimental/math/ray3/ray3DistanceToSphere';
    export * from '@0b5vr/experimental/math/ray3/ray3FromLine3';
}

declare module '@0b5vr/experimental/math/sphere3' {
    export * from '@0b5vr/experimental/math/sphere3/RawSphere3';
    export * from '@0b5vr/experimental/math/sphere3/Sphere3';
    export * from '@0b5vr/experimental/math/sphere3/sphere3ContainsPoint';
}

declare module '@0b5vr/experimental/math/vec' {
    export { vecAbs } from '@0b5vr/experimental/math/vec/vecAbs';
    export { vecAdd } from '@0b5vr/experimental/math/vec/vecAdd';
    export { vecDivide } from '@0b5vr/experimental/math/vec/vecDivide';
    export { vecDot } from '@0b5vr/experimental/math/vec/vecDot';
    export { vecLength } from '@0b5vr/experimental/math/vec/vecLength';
    export { vecLengthSq } from '@0b5vr/experimental/math/vec/vecLengthSq';
    export { vecManhattanLength } from '@0b5vr/experimental/math/vec/vecManhattanLength';
    export { vecMultiply } from '@0b5vr/experimental/math/vec/vecMultiply';
    export { vecNeg } from '@0b5vr/experimental/math/vec/vecNeg';
    export { vecNormalize } from '@0b5vr/experimental/math/vec/vecNormalize';
    export { vecScale } from '@0b5vr/experimental/math/vec/vecScale';
    export { vecSub } from '@0b5vr/experimental/math/vec/vecSub';
    export { Vector } from '@0b5vr/experimental/math/vec/Vector';
}

declare module '@0b5vr/experimental/math/vec3' {
    export type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    export { vec3ApplyMatrix3 } from '@0b5vr/experimental/math/vec3/vec3ApplyMatrix3';
    export { vec3ApplyMatrix4 } from '@0b5vr/experimental/math/vec3/vec3ApplyMatrix4';
    export { vec3ApplyQuaternion } from '@0b5vr/experimental/math/vec3/vec3ApplyQuaternion';
    export { vec3Cross } from '@0b5vr/experimental/math/vec3/vec3Cross';
    export { vec3OrthoNormalize } from '@0b5vr/experimental/math/vec3/vec3OrthoNormalize';
    export { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
}

declare module '@0b5vr/experimental/math/vec4' {
    export type { RawVector4 } from '@0b5vr/experimental/math/vec4/RawVector4';
    export { vec4ApplyMatrix3 } from '@0b5vr/experimental/math/vec4/vec4ApplyMatrix3';
    export { vec4ApplyMatrix4 } from '@0b5vr/experimental/math/vec4/vec4ApplyMatrix4';
    export { Vector4 } from '@0b5vr/experimental/math/vec4/Vector4';
}

declare module '@0b5vr/experimental/math/mod' {
    /**
      * GLSL Style `mod` function.
      * "compute value of one parameter modulo another"
      */
    export function mod(value: number, divisor: number): number;
}

declare module '@0b5vr/experimental/math/sanitizeAngle' {
    /**
      * Enclose arbitrary angle (in radian) into [-π, π)
      */
    export function sanitizeAngle(angle: number): number;
}

declare module '@0b5vr/experimental/math/utils' {
    /**
        * `lerp`, or `mix`
        */
    export function lerp(a: number, b: number, x: number): number;
    /**
        * `clamp`
        */
    export function clamp(x: number, l: number, h: number): number;
    /**
        * `clamp( x, 0.0, 1.0 )`
        */
    export function saturate(x: number): number;
    /**
        * Transform a value from input range to output range.
        */
    export function range(x: number, x0: number, x1: number, y0: number, y1: number): number;
    /**
        * `smoothstep` but not smooth
        */
    export function linearstep(a: number, b: number, x: number): number;
    /**
        * world famous `smoothstep` function
        */
    export function smoothstep(a: number, b: number, x: number): number;
    /**
        * `smoothstep` but more smooth
        */
    export function smootherstep(a: number, b: number, x: number): number;
    /**
        * `smoothstep` but WAY more smooth
        */
    export function smootheststep(a: number, b: number, x: number): number;
}

declare module '@0b5vr/experimental/midi/midiParse' {
    import { MidiParseResult } from '@0b5vr/experimental/midi/MidiParseResult';
    export function midiParse(buffer: ArrayBuffer): MidiParseResult;
}

declare module '@0b5vr/experimental/midi/MidiParseResult' {
    export type MidiParseResultHeader = [
        format: number,
        tracks: number,
        division: number
    ];
    export type MidiParseResultTrackNoteEvent = [
        tick: number,
        type: number,
        note: number,
        velocity: number
    ];
    export type MidiParseResultTrackMetaEvent = [
        tick: number,
        type: number,
        subtype: number,
        data: number[]
    ];
    export type MidiParseResultTrackEvent = MidiParseResultTrackNoteEvent | MidiParseResultTrackMetaEvent;
    export type MidiParseResultTrack = MidiParseResultTrackEvent[];
    export type MidiParseResult = [
        header: MidiParseResultHeader,
        tracks: MidiParseResultTrack[]
    ];
}

declare module '@0b5vr/experimental/poker/createPokerDeck' {
    import type { PokerCard } from '@0b5vr/experimental/poker/PokerCard';
    /**
      * Create a 52-card deck.
      * You might want to use {@link shuffleArray} to shuffle the deck.
      */
    export function createPokerDeck(): PokerCard[];
}

declare module '@0b5vr/experimental/poker/evaluatePokerHand' {
    import type { PokerCard } from '@0b5vr/experimental/poker/PokerCard';
    import type { PokerHand } from '@0b5vr/experimental/poker/PokerHand';
    export interface EvaluatePokerHandResult {
        hand: PokerHand;
        strength: number[];
        cards: [PokerCard, PokerCard, PokerCard, PokerCard, PokerCard];
    }
    export function evaluatePokerHand(cards: PokerCard[]): EvaluatePokerHandResult;
}

declare module '@0b5vr/experimental/poker/PokerCard' {
    import { PokerRank } from '@0b5vr/experimental/poker/PokerRank';
    import { PokerSuit } from '@0b5vr/experimental/poker/PokerSuit';
    export type PokerCard = `${PokerRank}${PokerSuit}`;
}

declare module '@0b5vr/experimental/poker/PokerHand' {
    export type PokerHand = 'HighCard' | 'OnePair' | 'TwoPair' | 'ThreeOfAKind' | 'Straight' | 'Flush' | 'FullHouse' | 'FourOfAKind' | 'StraightFlush';
}

declare module '@0b5vr/experimental/poker/pokerHandsByStrength' {
    import type { PokerHand } from '@0b5vr/experimental/poker/PokerHand';
    export const pokerHandsByStrength: PokerHand[];
}

declare module '@0b5vr/experimental/poker/pokerHandStrengthMap' {
    import { PokerHand } from '@0b5vr/experimental/poker/PokerHand';
    export const pokerHandStrengthMap: {
        [hand in PokerHand]: number;
    };
}

declare module '@0b5vr/experimental/poker/PokerRank' {
    export type PokerRank = '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'T' | 'J' | 'Q' | 'K' | 'A';
}

declare module '@0b5vr/experimental/poker/pokerRanksByStrength' {
    import type { PokerRank } from '@0b5vr/experimental/poker/PokerRank';
    export const pokerRanksByStrength: PokerRank[];
}

declare module '@0b5vr/experimental/poker/pokerRankStrengthMap' {
    import type { PokerRank } from '@0b5vr/experimental/poker/PokerRank';
    export const pokerRankStrengthMap: {
        [rank in PokerRank]: number;
    };
}

declare module '@0b5vr/experimental/poker/PokerSuit' {
    export type PokerSuit = 's' | 'c' | 'h' | 'd';
}

declare module '@0b5vr/experimental/poker/pokerSuitIndexMap' {
    import type { PokerSuit } from '@0b5vr/experimental/poker/PokerSuit';
    export const pokerSuitIndexMap: {
        [suit in PokerSuit]: number;
    };
}

declare module '@0b5vr/experimental/poker/pokerSuitsByIndex' {
    import type { PokerSuit } from '@0b5vr/experimental/poker/PokerSuit';
    export const pokerSuitsByIndex: PokerSuit[];
}

declare module '@0b5vr/experimental/poker/sortPokerCardsByRank' {
    import type { PokerCard } from '@0b5vr/experimental/poker/PokerCard';
    /**
      * Sort given array of cards in place by rank (and suit).
      */
    export function sortPokerCardsByRank(cards: PokerCard[]): PokerCard[];
}

declare module '@0b5vr/experimental/Pool/Pool' {
    export class Pool<T> {
        array: T[];
        index: number;
        get current(): T;
        constructor(array: T[]);
        next(): T;
    }
}

declare module '@0b5vr/experimental/retry/asyncRetry' {
    /**
      * Retry given function for n times.
      *
      * See also: {@link retry}
      */
    export function asyncRetry<T>(func: () => Promise<T>, n: number): Promise<T>;
}

declare module '@0b5vr/experimental/retry/retry' {
    /**
      * Retry given function for n times.
      *
      * See also: {@link asyncRetry}
      */
    export function retry<T>(func: () => T, n: number): T;
}

declare module '@0b5vr/experimental/stniccc/parseSTNICCC' {
    import { STNICCCFrame } from '@0b5vr/experimental/stniccc/STNICCCFrame';
    /**
      * Ref: http://arsantica-online.com/st-niccc-competition/
      *
      * @param buffer The input ST-NICCC data
      */
    export function parseSTNICCC(buffer: ArrayBuffer): STNICCCFrame[];
}

declare module '@0b5vr/experimental/stniccc/STNICCCFrame' {
    export interface STNICCCFrameIndexed {
        needsClear: boolean;
        indexedMode: true;
        palette: number[];
        vertices: number[];
        polygons: {
            colorIndex: number;
            indices: number[];
        }[];
    }
    export interface STNICCCFrameNonIndexed {
        needsClear: boolean;
        indexedMode: false;
        palette: number[];
        polygons: {
            colorIndex: number;
            vertices: number[];
        }[];
    }
    export type STNICCCFrame = STNICCCFrameIndexed | STNICCCFrameNonIndexed;
}

declare module '@0b5vr/experimental/stniccc/stnicccToSVG' {
    import { STNICCCFrame } from '@0b5vr/experimental/stniccc/STNICCCFrame';
    export function stnicccToSVG(frames: STNICCCFrame[], options?: {
        fps?: number;
    }): string;
}

declare module '@0b5vr/experimental/SmoothDamp/SmoothDamp' {
    /**
      * The naive implementation of so-called SmoothDamp.
      * Pretty much the same as {@link CDS}, but it has a way easier parameter to tweak, {@link smoothTime}.
      *
      * Ref: Game Programming Gems 4, Chapter 1.10
      *
      * See: https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Mathf.cs#L308
      */
    export class SmoothDamp {
        smoothTime: number;
        velocity: number;
        value: number;
        target: number;
        update(deltaTime: number): number;
    }
}

declare module '@0b5vr/experimental/Swap/Swap' {
    /**
      * Useful for swap buffer
      */
    export class Swap<T> {
        i: T;
        o: T;
        constructor(a: T, b: T);
        swap(): void;
    }
}

declare module '@0b5vr/experimental/TapTempo/TapTempo' {
    export class TapTempo {
        get beatDuration(): number;
        get bpm(): number;
        set bpm(bpm: number);
        get beat(): number;
        reset(): void;
        nudge(amount: number): void;
        tap(): void;
    }
}

declare module '@0b5vr/experimental/tinyseq/createTinyseqPolyReader' {
    /**
      * Parse a polyphonic tinyseq buffer.
      *
      * Returns [ time, offTime, note, reserved, time, offTime, note, reserved, ... ]
      */
    export function createTinyseqPolyReader(buffer: Uint8Array, options?: {
        poly?: number;
        blockSize?: number;
        sampleRate?: number;
        stepsPerSecond?: number;
    }): () => Float32Array[];
}

declare module '@0b5vr/experimental/tinyseq/createTinyseqReader' {
    /**
      * Parse a tinyseq buffer.
      *
      * Returns [ time, offTime, note, reserved, time, offTime, note, reserved, ... ]
      */
    export function createTinyseqReader(buffer: Uint8Array, options?: {
        blockSize?: number;
        sampleRate?: number;
        stepsPerSecond?: number;
    }): () => Float32Array;
}

declare module '@0b5vr/experimental/tinyseq/tinyseqFromMidiParseResult' {
    import { MidiParseResult } from '@0b5vr/experimental/midi';
    /**
      * Convert the parsed midi result to a tinyseq binary.
      *
      * See: {@link midiParse}
      *
      * @param midi The parsed midi result
      * @param track The index of the midi track you want to convert
      * @param tickMultiplier Multiply this value to tick
      * @returns A tinyseq binary
      */
    export function tinyseqFromMidiParseResult(midi: MidiParseResult, { track, tickMultiplier }?: {
        track?: number;
        tickMultiplier?: number;
    }): Uint8Array;
}

declare module '@0b5vr/experimental/Xorshift/Xorshift' {
    export class Xorshift {
        seed: number;
        constructor(seed?: number);
        gen(seed?: number): number;
        set(seed?: number): void;
    }
    export default Xorshift;
}

declare module '@0b5vr/experimental/yugop/getYugopText' {
    /**
      * https://twitter.com/yugop
      *
      * @param text The input text
      * @param phase The value between 0.0 and 1.0
      * @param randomRatio The nerd value
      */
    export function getYugopText(text: string, phase: number, randomRatio?: number): string;
}

declare module '@0b5vr/experimental/math/box3/Box3' {
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawBox3 } from '@0b5vr/experimental/math/box3/RawBox3';
    /**
        * A 3D box.
        */
    export class Box3 {
            min: Vector3;
            max: Vector3;
            constructor(min?: Vector3, max?: Vector3);
            /**
                * Itself but {@link RawBox3} form.
                */
            get raw(): RawBox3;
            /**
                * Test if given point is contained in the box or not.
                *
                * @param point A point
                */
            containsPoint(point: Vector3): boolean;
            /**
                * Convert {@link RawBox3} to class form.
                * @param box A {@link RawBox3}
                */
            static fromRaw(box: RawBox3): Box3;
    }
}

declare module '@0b5vr/experimental/math/box3/box3ContainsPoint' {
    import type { RawBox3 } from '@0b5vr/experimental/math/box3/RawBox3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Test if given point is contained in given box or not.
      * @param box A box
      * @param point A point
      */
    export function box3ContainsPoint(box: RawBox3, point: RawVector3): boolean;
}

declare module '@0b5vr/experimental/math/box3/RawBox3' {
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    export type RawBox3 = [min: RawVector3, max: RawVector3];
}

declare module '@0b5vr/experimental/math/euler/Euler' {
    import { Matrix3 } from '@0b5vr/experimental/math/mat3/Matrix3';
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Quaternion } from '@0b5vr/experimental/math/quat/Quaternion';
    import type { EulerOrder } from '@0b5vr/experimental/math/euler/EulerOrder';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
        * An Euler rotations.
        */
    export class Euler {
            elements: RawVector3;
            /**
                * An order of this euler.
                * 'XYZ' by default.
                *
                * Note that this is **extrinsic** rotations (which is same as Blender, Maya, and Unity).
                * Three.js uses intrinsic rotations so you have to reverse the order if you want to match the behavior with Three.js.
                */
            order: EulerOrder;
            constructor(elements?: RawVector3, order?: EulerOrder);
            /**
                * An x component of this.
                */
            get x(): number;
            /**
                * An y component of this.
                */
            get y(): number;
            /**
                * An z component of this.
                */
            get z(): number;
            toString(): string;
            /**
                * Clone this.
                */
            clone(): Euler;
            /**
                * Itself but converted into a Quaternion.
                */
            get quaternion(): Quaternion;
            /**
                * Itself but converted into a Matrix4.
                */
            get matrix4(): Matrix4;
            /**
                * Generate an Euler out of a matrix3.
                */
            static fromMatrix3(matrix: Matrix3, order: EulerOrder): Euler;
            /**
                * Generate an Euler out of a matrix4.
                */
            static fromMatrix4(matrix: Matrix4, order: EulerOrder): Euler;
            /**
                * Generate an Euler out of a quaternion.
                */
            static fromQuaternion(quaternion: Quaternion, order: EulerOrder): Euler;
    }
}

declare module '@0b5vr/experimental/math/euler/eulerFromMat3' {
    import type { EulerOrder } from '@0b5vr/experimental/math/euler/EulerOrder';
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a euler angles out of a matrix3.
      * Make sure the input matrix is normalized.
      *
      * @param m An input rotation matrix
      * @param order An order of output euler angles. Assume as `XYZ` if not specified
      */
    export function eulerFromMat3(m: RawMatrix3, order?: EulerOrder): RawVector3;
}

declare module '@0b5vr/experimental/math/euler/eulerFromMat4' {
    import type { EulerOrder } from '@0b5vr/experimental/math/euler/EulerOrder';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a euler angles out of a matrix4.
      * Make sure the input matrix is normalized.
      *
      * @param m An input rotation matrix
      * @param order An order of output euler angles. Assume as `XYZ` if not specified
      */
    export function eulerFromMat4(m: RawMatrix4, order?: EulerOrder): RawVector3;
}

declare module '@0b5vr/experimental/math/euler/eulerFromQuaternion' {
    import type { EulerOrder } from '@0b5vr/experimental/math/euler/EulerOrder';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a euler angles out of a quaternion.
      *
      * @param m An input quaternion
      * @param order An order of output euler angles. Assume as `XYZ` if not specified
      */
    export function eulerFromQuaternion(m: RawQuaternion, order?: EulerOrder): RawVector3;
}

declare module '@0b5vr/experimental/math/euler/EulerOrder' {
    /**
      * Note that this is **extrinsic** rotations (which is same as Blender, Maya, and Unity).
      * Three.js uses intrinsic rotations so you have to reverse the order if you want to match the behavior with Three.js.
      */
    export type EulerOrder = 'XYZ' | 'XZY' | 'YXZ' | 'YZX' | 'ZXY' | 'ZYX';
}

declare module '@0b5vr/experimental/math/line3/Line3' {
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Ray3 } from '@0b5vr/experimental/math/ray3/Ray3';
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    /**
        * A 3D line.
        */
    export class Line3 {
            start: Vector3;
            end: Vector3;
            constructor(start?: Vector3, end?: Vector3);
            /**
                * Itself but {@link RawLine3} form.
                */
            get raw(): RawLine3;
            /**
                * Itself but a ray.
                */
            get ray(): Ray3;
            /**
                * A vector that represents delta of the line.
                */
            delta(): Vector3;
            /**
                * Its length.
                */
            length(): number;
            /**
                * Return a vector that represents a certain point of the line.
                * Same as start at t = 0, same as end at t = 1.
                *
                * @param t A parameter t
                */
            at(t: number): Vector3;
            /**
                * Apply given matrix4 to the line.
                *
                * @param matrix A matrix4 which will be applied to the line
                */
            applyMatrix4(matrix: Matrix4): Line3;
            /**
                * Return a point that is on the line which is closest to the given point.
                *
                * If `segment` is true, it will treat the line as a segment which has start and end.
                * Otherwise it will treat the line is infinite.
                *
                * @param point A point
                * @param segment Is the line a segment?
                */
            closestPointToPoint(point: Vector3, segment: boolean): Vector3;
            /**
                * Return a distance from the line to the given point.
                *
                * If `segment` is true, it will treat the line as a segment which has start and end.
                * Otherwise it will treat the line is infinite.
                *
                * @param point A point
                * @param segment Is the line a segment?
                */
            distanceToPoint(point: Vector3, segment: boolean): number;
            /**
                * Convert {@link RawLine3} to class form.
                * @param line A {@link RawLine3}
                */
            static fromRaw(line: RawLine3): Line3;
    }
}

declare module '@0b5vr/experimental/math/line3/line3ApplyMatrix4' {
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Apply given matrix4 to given line.
      *
      * @param line A line
      * @param matrix A matrix4 which will be applied to the line
      */
    export function line3ApplyMatrix4([start, end]: RawLine3, matrix: RawMatrix4): RawLine3;
}

declare module '@0b5vr/experimental/math/line3/line3At' {
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a vector that represents a certain point of given line.
      * Same as start at t = 0, same as end at t = 1.
      *
      * @param line A line
      * @param t A parameter t
      */
    export function line3At(line: RawLine3, t: number): RawVector3;
}

declare module '@0b5vr/experimental/math/line3/line3ClosestPointToPoint' {
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a point that is on the given line which is closest to the given point.
      *
      * If `segment` is true, it will treat the line as a segment which has start and end.
      * Otherwise it will treat the line is infinite.
      *
      * @param line A line
      * @param point A point
      * @param segment Is the line a segment?
      */
    export function line3ClosestPointToPoint(line: RawLine3, point: RawVector3, segment?: boolean): RawVector3;
}

declare module '@0b5vr/experimental/math/line3/line3Delta' {
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a vector that represents delta of given line.
      *
      * @param line A line
      */
    export function line3Delta(line: RawLine3): RawVector3;
}

declare module '@0b5vr/experimental/math/line3/line3DistanceToPoint' {
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a distance from the given line to the given point.
      *
      * If `segment` is true, it will treat the line as a segment which has start and end.
      * Otherwise it will treat the line is infinite.
      *
      * @param line A line
      * @param point A point
      * @param segment Is the line a segment?
      */
    export function line3DistanceToPoint(line: RawLine3, point: RawVector3, segment?: boolean): number;
}

declare module '@0b5vr/experimental/math/line3/RawLine3' {
    import { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    export type RawLine3 = [start: RawVector3, end: RawVector3];
}

declare module '@0b5vr/experimental/math/mat2/mat2Determinant' {
    import type { RawMatrix2 } from '@0b5vr/experimental/math/mat2/RawMatrix2';
    export function mat2Determinant(m: RawMatrix2): number;
}

declare module '@0b5vr/experimental/math/mat2/mat2Inverse' {
    import type { RawMatrix2 } from '@0b5vr/experimental/math/mat2/RawMatrix2';
    /**
      * Return an inverse of given matrix.
      */
    export function mat2Inverse(m: RawMatrix2): RawMatrix2;
}

declare module '@0b5vr/experimental/math/mat2/mat2Multiply' {
    import type { RawMatrix2 } from '@0b5vr/experimental/math/mat2/RawMatrix2';
    /**
      * Return a multiplication result of matrices.
      */
    export function mat2Multiply(...mats: RawMatrix2[]): RawMatrix2;
}

declare module '@0b5vr/experimental/math/mat2/mat2Transpose' {
    import type { RawMatrix2 } from '@0b5vr/experimental/math/mat2/RawMatrix2';
    /**
      * Transpose a mat2.
      */
    export function mat2Transpose(source: RawMatrix2): RawMatrix2;
}

declare module '@0b5vr/experimental/math/mat2/Matrix2' {
    import type { RawMatrix2 } from '@0b5vr/experimental/math/mat2/RawMatrix2';
    /**
        * A Matrix2.
        */
    export class Matrix2 {
            elements: RawMatrix2;
            constructor(v?: RawMatrix2);
            /**
                * Itself but transposed.
                */
            get transpose(): Matrix2;
            /**
                * Its determinant.
                */
            get determinant(): number;
            /**
                * Itself but inverted.
                */
            get inverse(): Matrix2;
            toString(): string;
            /**
                * Clone this.
                */
            clone(): Matrix2;
            /**
                * Multiply this Matrix2 by one or more Matrix2s.
                */
            multiply(...matrices: Matrix2[]): Matrix2;
            /**
                * Multiply this Matrix3 by a scalar.
                */
            scaleScalar(scalar: number): Matrix2;
            /**
                * An identity Matrix4.
                */
            static get identity(): Matrix2;
            /**
                * Multiply two or more matrices.
                * @param matrices Matrices
                */
            static multiply(...matrices: Matrix2[]): Matrix2;
    }
}

declare module '@0b5vr/experimental/math/mat2/RawMatrix2' {
    export type RawMatrix2 = [
        number,
        number,
        number,
        number
    ];
}

declare module '@0b5vr/experimental/math/mat3/mat3CreateNormalMatrix' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Create a normal matrix out of a matrix4.
      *
      * @param matrix A matrix4
      */
    export function mat3CreateNormalMatrix(m: RawMatrix4): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/mat3Determinant' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    export function mat3Determinant(m: RawMatrix3): number;
}

declare module '@0b5vr/experimental/math/mat3/mat3FromMat4' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Create a matrix3 from matrix4.
      */
    export function mat3FromMat4(source: RawMatrix4): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/mat3FromMat4Transpose' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Who needs this?
      *
      * Intended to be used by {@link mat3CreateNormalMatrix}.
      */
    export function mat3FromMat4Transpose(source: RawMatrix4): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/mat3FromQuaternion' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Convert a quaternion into a matrix3.
      *
      * Yoinked from Three.js.
      *
      * See: https://threejs.org/docs/#api/en/math/Matrix4.makeRotationFromQuaternion
      */
    export function mat3FromQuaternion(quat: RawQuaternion): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/mat3Inverse' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    /**
      * Return an inverse of given mat3.
      *
      * Yoinked from Three.js
      */
    export function mat3Inverse(m: RawMatrix3): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/mat3Multiply' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    /**
      * Return a multiplication result of matrices.
      */
    export function mat3Multiply(...mats: RawMatrix3[]): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/mat3Transpose' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    /**
      * Transpose a mat3.
      */
    export function mat3Transpose(source: RawMatrix3): RawMatrix3;
}

declare module '@0b5vr/experimental/math/mat3/Matrix3' {
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Quaternion } from '@0b5vr/experimental/math/quat/Quaternion';
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    /**
        * A Matrix3.
        */
    export class Matrix3 {
            elements: RawMatrix3;
            constructor(v?: RawMatrix3);
            /**
                * Itself but transposed.
                */
            get transpose(): Matrix3;
            /**
                * Its determinant.
                */
            get determinant(): number;
            /**
                * Itself but inverted.
                */
            get inverse(): Matrix3;
            /**
                * Itself but matrix4.
                */
            get matrix4(): Matrix4;
            toString(): string;
            /**
                * Clone this.
                */
            clone(): Matrix3;
            /**
                * Multiply this Matrix3 by one or more Matrix3s.
                */
            multiply(...matrices: Matrix3[]): Matrix3;
            /**
                * Multiply this Matrix3 by a scalar.
                */
            scaleScalar(scalar: number): Matrix3;
            /**
                * An identity Matrix4.
                */
            static get identity(): Matrix3;
            /**
                * Multiply two or more matrices.
                * @param matrices Matrices
                */
            static multiply(...matrices: Matrix3[]): Matrix3;
            /**
                * Create a normal matrix out of matrix4.
                * @param matrix4 A matrix4
                */
            static createNormalMatrix(matrix4: Matrix4): Matrix3;
            /**
                * Cast a {@link Matrix4} into a Matrix3.
                * @param matrix4 A matrix4
                */
            static fromMatrix4(matrix4: Matrix4): Matrix3;
            /**
                * Create a matrix out of a {@link Quaternion}.
                * @param quaternion A quaternion
                */
            static fromQuaternion(quaternion: Quaternion): Matrix3;
    }
}

declare module '@0b5vr/experimental/math/mat3/RawMatrix3' {
    export type RawMatrix3 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
    ];
}

declare module '@0b5vr/experimental/math/mat4/mat4Compose' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Compose a matrix out of position, scale, and rotation.
      * Yoinked from Three.js.
      */
    export function mat4Compose(position: RawVector3, rotation: RawQuaternion, scale: RawVector3): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Decompose' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Decompose a matrix into a position, a scale, and a rotation.
      * Yoinked from Three.js.
      */
    export function mat4Decompose(m: RawMatrix4): {
        position: RawVector3;
        scale: RawVector3;
        rotation: RawQuaternion;
    };
}

declare module '@0b5vr/experimental/math/mat4/mat4Determinant' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Return a determinant of given mat4.
      */
    export function mat4Determinant(m: RawMatrix4): number;
}

declare module '@0b5vr/experimental/math/mat4/mat4FromMat3' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Create a matrix4 from matrix3.
      */
    export function mat4FromMat3(source: RawMatrix3): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4FromQuaternion' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Convert a quaternion into a matrix4.
      *
      * Yoinked from Three.js.
      *
      * See: https://threejs.org/docs/#api/en/math/Matrix4.makeRotationFromQuaternion
      */
    export function mat4FromQuaternion(quat: RawQuaternion): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Inverse' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      *  an inverse of given mat4.
      */
    export function mat4Inverse(m: RawMatrix4): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4LookAt' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Generate a "LookAt" matrix.
      *
      * See also: {@link mat4LookAtInverse}
      */
    export function mat4LookAt(position: RawVector3, target?: RawVector3, up?: RawVector3, roll?: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4LookAtInverse' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Generate an inverse of "LookAt" matrix. Good for creating a view matrix.
      *
      * See also: {@link mat4LookAt}
      */
    export function mat4LookAtInverse(position: RawVector3, target?: RawVector3, up?: RawVector3, roll?: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Multiply' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Return a multiplication result of matrices.
      */
    export function mat4Multiply(...mats: RawMatrix4[]): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Perspective' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Generate a "Perspective" projection matrix.
      *
      * @param fov Field of View Y, **IN DEGREES**
      * @param near Near clip plane
      * @param far Far clip plane
      * @param aspect Aspect ratio. **`1.0` BY DEFAULT**
      */
    export function mat4Perspective(fov?: number, near?: number, far?: number, aspect?: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4RotationX' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Generate a 3d rotation matrix, rotates around x axis.
      */
    export function mat4RotationX(theta: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4RotationY' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Generate a 3d rotation matrix, rotates around y axis.
      */
    export function mat4RotationY(theta: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4RotationZ' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Generate a 3d rotation matrix, rotates around z axis.
      */
    export function mat4RotationZ(theta: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Scale' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Generate a 3d scaling matrix.
      */
    export function mat4Scale(vec: RawVector3): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4ScaleScalar' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Generate a 3d scaling matrix by a scalar.
      */
    export function mat4ScaleScalar(scalar: number): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Translate' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Generate a translation matrix.
      */
    export function mat4Translate(vec: RawVector3): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/mat4Transpose' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
      * Transpose a mat4.
      */
    export function mat4Transpose(m: RawMatrix4): RawMatrix4;
}

declare module '@0b5vr/experimental/math/mat4/Matrix4' {
    import { Matrix3 } from '@0b5vr/experimental/math/mat3/Matrix3';
    import { Quaternion } from '@0b5vr/experimental/math/quat/Quaternion';
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    /**
        * A Matrix4.
        */
    export class Matrix4 {
            elements: RawMatrix4;
            constructor(v?: RawMatrix4);
            /**
                * Itself but transposed.
                */
            get transpose(): Matrix4;
            /**
                * Its determinant.
                */
            get determinant(): number;
            /**
                * Itself but inverted.
                */
            get inverse(): Matrix4;
            /**
                * Itself but matrix3.
                */
            get matrix3(): Matrix3;
            /**
                * Itself but normal matrix.
                */
            get normalMatrix(): Matrix3;
            toString(): string;
            /**
                * Clone this.
                */
            clone(): Matrix4;
            /**
                * Multiply this Matrix4 by one or more Matrix4s.
                */
            multiply(...matrices: Matrix4[]): Matrix4;
            /**
                * Multiply this Matrix4 by a scalar.
                */
            scaleScalar(scalar: number): Matrix4;
            /**
                * Decompose this matrix into a position, a scale, and a rotation.
                */
            decompose(): {
                    position: Vector3;
                    scale: Vector3;
                    rotation: Quaternion;
            };
            /**
                * An identity Matrix4.
                */
            static get identity(): Matrix4;
            /**
                * Multiply two or more matrices.
                * @param matrices Matrices
                */
            static multiply(...matrices: Matrix4[]): Matrix4;
            /**
                * Create a matrix out of a {@link Quaternion}.
                * @param quaternion A quaternion
                */
            static fromQuaternion(quaternion: Quaternion): Matrix4;
            /**
                * Cast a {@link Matrix3} into a Matrix4.
                * @param matrix3 A matrix3
                */
            static fromMatrix3(matrix3: Matrix3): Matrix4;
            /**
                * Generate a translation matrix.
                * @param vector Translation
                */
            static translate(vector: Vector3): Matrix4;
            /**
                * Generate a 3d scaling matrix.
                * @param vector Scale
                */
            static scale(vector: Vector3): Matrix4;
            /**
                * Generate a 3d scaling matrix by a scalar.
                * @param vector Scale
                */
            static scaleScalar(scalar: number): Matrix4;
            /**
                * Generate a 3d rotation matrix, rotates around x axis.
                * @param vector Scale
                */
            static rotationX(theta: number): Matrix4;
            /**
                * Generate a 3d rotation matrix, rotates around y axis.
                * @param vector Scale
                */
            static rotationY(theta: number): Matrix4;
            /**
                * Generate a 3d rotation matrix, rotates around z axis.
                * @param vector Scale
                */
            static rotationZ(theta: number): Matrix4;
            /**
                * Generate a "LookAt" matrix.
                *
                * See also: {@link lookAtInverse}
                */
            static lookAt(position: Vector3, target?: Vector3, up?: Vector3, roll?: number): Matrix4;
            /**
                * Generate an inverse of "LookAt" matrix. Good for creating a view matrix.
                *
                * See also: {@link lookAt}
                */
            static lookAtInverse(position: Vector3, target?: Vector3, up?: Vector3, roll?: number): Matrix4;
            /**
                * Generate a "Perspective" projection matrix.
                * It won't include aspect!
                */
            static perspective(fov?: number, near?: number, far?: number): Matrix4;
            /**
                * Compose a matrix out of position, scale, and rotation.
                * Yoinked from Three.js.
                */
            static compose(position: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
    }
}

declare module '@0b5vr/experimental/math/mat4/RawMatrix4' {
    export type RawMatrix4 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
    ];
}

declare module '@0b5vr/experimental/math/plane3/Plane3' {
    import { Matrix3 } from '@0b5vr/experimental/math/mat3/Matrix3';
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
        * A 3D plane.
        */
    export class Plane3 {
            normal: Vector3;
            distance: number;
            /**
                * Itself but {@link RawPlane3} form.
                */
            get raw(): RawPlane3;
            /**
                * Normalized plane?
                * This normalizes the normal and also divide distance by its original normal length.
                */
            get normalized(): Plane3;
            constructor(normal?: Vector3, distance?: number);
            /**
                * Apply given matrix4 to the plane.
                *
                * @param matrix A matrix4 which will be applied to the plane
                * @param normalMatrix A normalMatrix made out of {@link matrix}. Optional
                */
            applyMatrix4(matrix: Matrix4, normalMatrix?: Matrix3): Plane3;
            /**
                * Return a signed distance from given plane to the given point.
                *
                * @param point A point
                */
            distanceToPoint(point: Vector3): number;
            /**
                * Convert {@link RawPlane3} to class form.
                * @param plane A {@link RawPlane3}
                */
            static fromRaw(plane: RawPlane3): Plane3;
    }
}

declare module '@0b5vr/experimental/math/plane3/plane3ApplyMatrix4' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
      * Apply given matrix4 to given plane.
      *
      * @param plane A plane
      * @param matrix A matrix4 which will be applied to the plane
      * @param normalMatrix A normalMatrix made out of {@link matrix}
      */
    export function plane3ApplyMatrix4([normal, distance]: RawPlane3, matrix: RawMatrix4, normalMatrix: RawMatrix3): RawPlane3;
}

declare module '@0b5vr/experimental/math/plane3/plane3DistanceToPoint' {
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a signed distance from given plane to the given point.
      * Make sure the `normal` is normalized.
      */
    export function plane3DistanceToPoint([normal, distance]: RawPlane3, point: RawVector3): number;
}

declare module '@0b5vr/experimental/math/plane3/plane3Normalize' {
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
      * Normalize a given plane?
      * This normalizes the normal and also divide distance by its original normal length.
      *
      * I don't come up with any use cases other than {@link planesFromProjectionMatrix}.
      *
      * @param plane The plane you want to normalize
      */
    export function plane3Normalize([normal, distance]: RawPlane3): RawPlane3;
}

declare module '@0b5vr/experimental/math/plane3/Planes3' {
    import { Box3 } from '@0b5vr/experimental/math/box3/Box3';
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Plane3 } from '@0b5vr/experimental/math/plane3/Plane3';
    import { Sphere3 } from '@0b5vr/experimental/math/sphere3/Sphere3';
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
        * A set of {@link Plane3}.
        */
    export class Planes3 {
            planes: Plane3[];
            /**
                * Itself but {@link RawPlane3}[] form.
                */
            get raw(): RawPlane3[];
            constructor(planes: Plane3[]);
            /**
                * Test if given point is contained in the planes or not.
                *
                * @param point A point
                */
            containPoint(point: Vector3): boolean;
            /**
                * Test if given box intersects with the planes or not.
                *
                * @param box A box3
                */
            intersectBox3(box: Box3): boolean;
            /**
                * Test if given sphere intersects with the planes or not.
                *
                * It does not do strict intersection test but still should work well with frustum cull use cases.
                * See the test case for more details.
                *
                * @param sphere A sphere3
                */
            intersectSphere3(sphere: Sphere3): boolean;
            /**
                * Convert {@link RawPlane3}[] to class form.
                *
                * @param planes A {@link RawPlane3}[]
                */
            static fromRaw(planes: RawPlane3[]): Planes3;
            /**
                * Generate a set of plane3 out of a {@link RawBox3}.
                *
                * @param box A box
                */
            static fromBox3(box: Box3): Planes3;
            /**
                * Create frustum planes out of given projection matrix.
                *
                * @param matrix A projection matrix
                */
            static fromProjectionMatrix(matrix: Matrix4): Planes3;
    }
}

declare module '@0b5vr/experimental/math/plane3/planes3ContainPoint' {
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Test if given point is contained in given planes or not.
      *
      * @param planes A list of planes
      * @param point A point
      */
    export function planes3ContainPoint(planes: RawPlane3[], point: RawVector3): boolean;
}

declare module '@0b5vr/experimental/math/plane3/planes3FromBox3' {
    import type { RawBox3 } from '@0b5vr/experimental/math/box3/RawBox3';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
      * Generate a set of plane3 out of a {@link RawBox3}.
      *
      * @param box A box
      */
    export function planes3FromBox3(box: RawBox3): RawPlane3[];
}

declare module '@0b5vr/experimental/math/plane3/planes3FromProjectionMatrix' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
      * Create frustum planes out of given projection matrix.
      *
      * @param m A projection matrix
      */
    export function planes3FromProjectionMatrix(m: RawMatrix4): RawPlane3[];
}

declare module '@0b5vr/experimental/math/plane3/planes3IntersectBox3' {
    import type { RawBox3 } from '@0b5vr/experimental/math/box3/RawBox3';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
      * Test if given box intersects with planes or not.
      *
      * @param planes A list of planes
      * @param box A box3
      */
    export function planes3IntersectBox3(planes: RawPlane3[], box: RawBox3): boolean;
}

declare module '@0b5vr/experimental/math/plane3/planes3IntersectSphere3' {
    import { RawSphere3 } from '@0b5vr/experimental/math/sphere3/RawSphere3';
    import type { RawPlane3 } from '@0b5vr/experimental/math/plane3/RawPlane3';
    /**
      * Test if given sphere intersects with planes or not.
      *
      * It does not do strict intersection test but still should work well with frustum cull use cases.
      * See the test case for more details.
      *
      * @param planes A list of planes
      * @param sphere A sphere3
      */
    export function planes3IntersectSphere3(planes: RawPlane3[], sphere: RawSphere3): boolean;
}

declare module '@0b5vr/experimental/math/plane3/RawPlane3' {
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    export type RawPlane3 = [normal: RawVector3, distance: number];
}

declare module '@0b5vr/experimental/math/quat/Quaternion' {
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
        * A Quaternion.
        */
    export class Quaternion {
            elements: RawQuaternion;
            constructor(elements?: RawQuaternion);
            /**
                * An x component of this.
                */
            get x(): number;
            /**
                * An y component of this.
                */
            get y(): number;
            /**
                * An z component of this.
                */
            get z(): number;
            /**
                * An w component of this.
                */
            get w(): number;
            toString(): string;
            /**
                * Clone this.
                */
            clone(): Quaternion;
            /**
                * Itself but converted into a Matrix4.
                */
            get matrix4(): Matrix4;
            /**
                * An inverse of this.
                */
            get inversed(): Quaternion;
            /**
                * The length of this.
                */
            get length(): number;
            /**
                * The squared length of this.
                */
            get lengthSq(): number;
            /**
                * A normalized this.
                */
            get normalized(): Quaternion;
            /**
                * Multiply one or more Quaternions with this.
                * @param quaternions Other Quaternions
                */
            multiply(...quaternions: Quaternion[]): Quaternion;
            /**
                * Interpolate between this and given quaternion.
                * @param b Another Quaternion
                * @param t How much do we want to rotate this to b
                */
            slerp(b: Quaternion, t: number): Quaternion;
            /**
                * An identity Quaternion.
                */
            static get identity(): Quaternion;
            /**
                * Multiply two or more matrices.
                * @param quaternion Quaternions
                */
            static multiply(...quaternions: Quaternion[]): Quaternion;
            /**
                * Interpolate between two quaternions.
                * @param a "from" quaternion
                * @param b "to" quaternion
                * @param t How much do we want to rotate the a to b
                */
            static slerp(a: Quaternion, b: Quaternion, t: number): Quaternion;
            /**
                * Return a quaternion which rotates around x axis.
                * @param theta An angle around x axis, in degree
                */
            static rotationX(theta: number): Quaternion;
            /**
                * Return a quaternion which rotates around y axis.
                * @param theta An angle around y axis, in degree
                */
            static rotationY(theta: number): Quaternion;
            /**
                * Return a quaternion which rotates around z axis.
                * @param theta An angle around z axis, in degree
                */
            static rotationZ(theta: number): Quaternion;
            /**
                * Return a quaternion which looks at the direction of `look`.
                * @param look Position where the quaternion will look at
                * @param up The "up vector"
                */
            static lookRotation(look: Vector3, up: Vector3): Quaternion;
            /**
                * Generate a Quaternion out of angle and axis.
                */
            static fromAxisAngle(axis: Vector3, angle: number): Quaternion;
            /**
                * Generate a Quaternion out of a rotation matrix.
                */
            static fromMatrix4(matrix: Matrix4): Quaternion;
    }
}

declare module '@0b5vr/experimental/math/quat/quatFromAxisAngle' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Generate a Quaternion out of axis and angle.
      */
    export function quatFromAxisAngle(axis: RawVector3, angle: number): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatFromEuler' {
    import type { EulerOrder } from '@0b5vr/experimental/math/euler/EulerOrder';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Generate a Quaternion out of euler angles.
      */
    export function quatFromEuler(euler: RawVector3, order?: EulerOrder): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatFromMatrix3' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Generate a Quaternion out of a rotation matrix.
      * Yoinked from Three.js.
      */
    export function quatFromMatrix3(m: RawMatrix3): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatFromMatrix4' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Generate a Quaternion out of a rotation matrix.
      */
    export function quatFromMatrix4(m: RawMatrix4): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatInverse' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Return an inverse of a quaternion.
      */
    export function quatInverse(quat: RawQuaternion): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatMultiply' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Return a multiplication result of quaternions.
      */
    export function quatMultiply(...quats: RawQuaternion[]): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatNormalize' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Normalize given quaternion.
      *
      * It's almost identical as {@link vecNormalize},
      * but it will return an identity quaternion instead
      * when it recieves a quaternion which length is zero.
      */
    export function quatNormalize(vec: RawQuaternion): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatRotationX' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Generate a quaternion rotates around x axis.
      * @param theta An angle around x axis, in degree
      */
    export function quatRotationX(theta: number): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatRotationY' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Generate a quaternion rotates around y axis.
      * @param theta An angle around y axis, in degree
      */
    export function quatRotationY(theta: number): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/quatRotationZ' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    /**
      * Generate a quaternion rotates around z axis.
      * @param theta An angle around z axis, in degree
      */
    export function quatRotationZ(theta: number): RawQuaternion;
}

declare module '@0b5vr/experimental/math/quat/RawQuaternion' {
    export type RawQuaternion = [number, number, number, number];
}

declare module '@0b5vr/experimental/math/ray3/RawRay3' {
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    export type RawRay3 = [ro: RawVector3, rd: RawVector3];
}

declare module '@0b5vr/experimental/math/ray3/Ray3' {
    import { Line3 } from '@0b5vr/experimental/math/line3/Line3';
    import { Sphere3 } from '@0b5vr/experimental/math/sphere3/Sphere3';
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawRay3 } from '@0b5vr/experimental/math/ray3/RawRay3';
    /**
        * A 3D ray.
        */
    export class Ray3 {
            /**
                * The origin of the ray.
                */
            origin: Vector3;
            /**
                * The direction of the ray.
                * Make sure the direction is normalized.
                */
            direction: Vector3;
            constructor(start?: Vector3, end?: Vector3);
            /**
                * Itself but {@link RawRay3} form.
                */
            get raw(): RawRay3;
            /**
                * Return distances from given ray to sphere.
                *
                * The returning distance can be negative.
                *
                * The first returning value will be the distance of the incident point.
                * If the ray does not intersect with sphere, it will return `null`.
                *
                * @param sphere A target sphere
                */
            distanceToSphere(sphere: Sphere3): [number, number] | null;
            /**
                * Convert {@link RawRay3} to class form.
                * @param ray A {@link RawRay3}
                */
            static fromRaw(ray: RawRay3): Ray3;
            /**
                * Create a ray out of a line.
                *
                * @param line A {@link Line3}
                */
            static fromLine3(line: Line3): Ray3;
    }
}

declare module '@0b5vr/experimental/math/ray3/ray3DistanceToSphere' {
    import type { RawRay3 } from '@0b5vr/experimental/math/ray3/RawRay3';
    import type { RawSphere3 } from '@0b5vr/experimental/math/sphere3/RawSphere3';
    /**
      * Return distances from given ray to sphere.
      *
      * The returning distance can be negative.
      *
      * The first returning value will be the distance of the incident point.
      * If the ray does not intersect with sphere, it will return `null`.
      *
      * @param ray A ray
      * @param sphere A target sphere
      */
    export function ray3DistanceToSphere([ro, rd]: RawRay3, sphere: RawSphere3): [number, number] | null;
}

declare module '@0b5vr/experimental/math/ray3/ray3FromLine3' {
    import type { RawLine3 } from '@0b5vr/experimental/math/line3/RawLine3';
    import type { RawRay3 } from '@0b5vr/experimental/math/ray3/RawRay3';
    /**
      * Convert the given line to a ray.
      *
      * @param line A line
      */
    export function ray3FromLine3(line: RawLine3): RawRay3;
}

declare module '@0b5vr/experimental/math/sphere3/RawSphere3' {
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    export type RawSphere3 = [origin: RawVector3, radius: number];
}

declare module '@0b5vr/experimental/math/sphere3/Sphere3' {
    import { Vector3 } from '@0b5vr/experimental/math/vec3/Vector3';
    import type { RawSphere3 } from '@0b5vr/experimental/math/sphere3/RawSphere3';
    /**
        * A 3D sphere.
        */
    export class Sphere3 {
            origin: Vector3;
            radius: number;
            constructor(origin?: Vector3, radius?: number);
            /**
                * Itself but {@link RawSphere3} form.
                */
            get raw(): RawSphere3;
            /**
                * Test if given point is contained in the sphere or not.
                *
                * @param point A point
                */
            containsPoint(point: Vector3): boolean;
            /**
                * Convert {@link RawSphere3} to class form.
                * @param sphere A {@link RawSphere3}
                */
            static fromRaw(sphere: RawSphere3): Sphere3;
    }
}

declare module '@0b5vr/experimental/math/sphere3/sphere3ContainsPoint' {
    import type { RawSphere3 } from '@0b5vr/experimental/math/sphere3/RawSphere3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Test if given point is contained in given sphere or not.
      * @param sphere A sphere
      * @param point A point
      */
    export function sphere3ContainsPoint(sphere: RawSphere3, point: RawVector3): boolean;
}

declare module '@0b5vr/experimental/math/vec/vecAbs' {
    /**
      * Return a vector with the absolute of each component of the given vector.
      */
    export function vecAbs<T extends number[]>(vec: T): T;
}

declare module '@0b5vr/experimental/math/vec/vecAdd' {
    /**
      * Return a sum of vectors.
      */
    export function vecAdd<T extends number[]>(...vecs: T[]): T;
}

declare module '@0b5vr/experimental/math/vec/vecDivide' {
    /**
      * Divide a vector by a vector.
      */
    export function vecDivide<T extends number[]>(vecA: T, vecB: T): T;
}

declare module '@0b5vr/experimental/math/vec/vecDot' {
    /**
      * Return a dot product of given two vectors.
      */
    export function vecDot<T extends number[]>(vecA: T, vecB: T): number;
}

declare module '@0b5vr/experimental/math/vec/vecLength' {
    /**
      * Return an euclidean length of given vector.
      */
    export function vecLength<T extends number[]>(vec: T): number;
}

declare module '@0b5vr/experimental/math/vec/vecLengthSq' {
    /**
      * Return an squared euclidean length of given vector.
      */
    export function vecLengthSq<T extends number[]>(vec: T): number;
}

declare module '@0b5vr/experimental/math/vec/vecManhattanLength' {
    /**
      * Return a manhattan length of given vector.
      */
    export function vecManhattanLength<T extends number[]>(vec: T): number;
}

declare module '@0b5vr/experimental/math/vec/vecMultiply' {
    /**
      * Return a product of vectors.
      */
    export function vecMultiply<T extends number[]>(...vecs: T[]): T;
}

declare module '@0b5vr/experimental/math/vec/vecNeg' {
    /**
      * Negate a vector.
      */
    export function vecNeg<T extends number[]>(vec: T): T;
}

declare module '@0b5vr/experimental/math/vec/vecNormalize' {
    /**
      * Normalize given vector.
      * If the length of given vector is 0.0, it will return a zero vector instead.
      */
    export function vecNormalize<T extends number[]>(vec: T): T;
}

declare module '@0b5vr/experimental/math/vec/vecScale' {
    /**
      * Scale the given vector by a scalar.
      */
    export function vecScale<T extends number[]>(vec: T, scalar: number): T;
}

declare module '@0b5vr/experimental/math/vec/vecSub' {
    /**
      * Subtract a vector from a vector.
      */
    export function vecSub<T extends number[]>(vecA: T, vecB: T): T;
}

declare module '@0b5vr/experimental/math/vec/Vector' {
    /**
        * A Vector.
        */
    export abstract class Vector<T extends Vector<T>> {
            abstract elements: number[];
            /**
                * The length of this.
                * a.k.a. `magnitude`
                */
            get length(): number;
            /**
                * The squared length of this.
                */
            get lengthSq(): number;
            /**
                * The manhattan length of this.
                */
            get manhattanLength(): number;
            /**
                * A normalized Vector3 of this.
                */
            get normalized(): T;
            /**
                * This but negated.
                */
            get negated(): T;
            /**
                * This but each component is the absolute.
                */
            get abs(): T;
            /**
                * Clone this.
                */
            clone(): T;
            /**
                * Add one or more Vector into this.
                * @param vectors Other Vectors
                */
            add(...vectors: T[]): T;
            /**
                * Substract this from another Vector.
                * @param v Another vector
                */
            sub(vector: T): T;
            /**
                * Multiply one or more Vector with this.
                * @param vectors Other Vectors
                */
            multiply(...vectors: T[]): T;
            /**
                * Divide this from another Vector.
                * @param vector Another Vector
                */
            divide(vector: T): T;
            /**
                * Scale this by scalar.
                * a.k.a. `multiplyScalar`
                * @param scalar A scalar
                */
            scale(scalar: number): T;
            /**
                * Dot two Vectors.
                * @param vector Another vector
                */
            dot(vector: T): number;
            protected abstract __new(v: number[]): T;
    }
}

declare module '@0b5vr/experimental/math/vec3/RawVector3' {
    export type RawVector3 = [number, number, number];
}

declare module '@0b5vr/experimental/math/vec3/vec3ApplyMatrix3' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Apply a vec3 a mat3.
      */
    export function vec3ApplyMatrix3(v: RawVector3, m: RawMatrix3): RawVector3;
}

declare module '@0b5vr/experimental/math/vec3/vec3ApplyMatrix4' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4/RawMatrix4';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Apply a vec3 (with an implicit 1 in the 4th dimension) a mat4.
      */
    export function vec3ApplyMatrix4(v: RawVector3, m: RawMatrix4): RawVector3;
}

declare module '@0b5vr/experimental/math/vec3/vec3ApplyQuaternion' {
    import type { RawQuaternion } from '@0b5vr/experimental/math/quat/RawQuaternion';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Apply a vec3 (with an implicit 1 in the 4th dimension) a quaternion.
      */
    export function vec3ApplyQuaternion(vec: RawVector3, quat: RawQuaternion): RawVector3;
}

declare module '@0b5vr/experimental/math/vec3/vec3Cross' {
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a cross product of two vec3s.
      */
    export function vec3Cross(vecA: RawVector3, vecB: RawVector3): RawVector3;
}

declare module '@0b5vr/experimental/math/vec3/vec3OrthoNormalize' {
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
      * Return a tangent which is orthogonal to normal.
      * If binormal is specified, it is also returned and it's orthogonal to both normal and tangent.
      */
    export function vec3OrthoNormalize(normal: RawVector3, tangent?: RawVector3, binormal?: RawVector3): {
        normal: RawVector3;
        tangent: RawVector3;
        binormal: RawVector3;
    };
}

declare module '@0b5vr/experimental/math/vec3/Vector3' {
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Quaternion } from '@0b5vr/experimental/math/quat/Quaternion';
    import { Vector } from '@0b5vr/experimental/math/vec/Vector';
    import type { RawVector3 } from '@0b5vr/experimental/math/vec3/RawVector3';
    /**
        * A Vector3.
        */
    export class Vector3 extends Vector<Vector3> {
            elements: RawVector3;
            constructor(v?: RawVector3);
            /**
                * An x component of this.
                */
            get x(): number;
            set x(x: number);
            /**
                * An y component of this.
                */
            get y(): number;
            set y(y: number);
            /**
                * An z component of this.
                */
            get z(): number;
            set z(z: number);
            toString(): string;
            /**
                * Return a cross of this and another Vector3.
                * @param vector Another vector
                */
            cross(vector: Vector3): Vector3;
            /**
                * Rotate this vector using a Quaternion.
                * @param quaternion A quaternion
                */
            applyQuaternion(quaternion: Quaternion): Vector3;
            /**
                * Multiply this vector (with an implicit 1 in the 4th dimension) by m.
                */
            applyMatrix4(matrix: Matrix4): Vector3;
            protected __new(v: RawVector3): Vector3;
            /**
                * Vector3( 0.0, 0.0, 0.0 )
                */
            static get zero(): Vector3;
            /**
                * Vector3( 1.0, 0.0, 0.0 )
                */
            static get px(): Vector3;
            /**
                * Vector3( -1.0, 0.0, 0.0 )
                */
            static get nx(): Vector3;
            /**
                * Vector3( 0.0, 1.0, 0.0 )
                */
            static get py(): Vector3;
            /**
                * Vector3( 0.0, -1.0, 0.0 )
                */
            static get ny(): Vector3;
            /**
                * Vector3( 0.0, 0.0, 1.0 )
                */
            static get pz(): Vector3;
            /**
                * Vector3( 0.0, 0.0, -1.0 )
                */
            static get nz(): Vector3;
            /**
                * Vector3( 1.0, 1.0, 1.0 )
                */
            static get one(): Vector3;
            /**
                * Return a tangent which is orthogonal to normal.
                * If binormal is specified, it is also returned and it's orthogonal to both normal and tangent.
                */
            static orthoNormalize(normal: Vector3, tangent: Vector3, binormal: Vector3): {
                    normal: Vector3;
                    tangent: Vector3;
                    binormal: Vector3;
            };
    }
}

declare module '@0b5vr/experimental/math/vec4/RawVector4' {
    export type RawVector4 = [number, number, number, number];
}

declare module '@0b5vr/experimental/math/vec4/vec4ApplyMatrix3' {
    import type { RawMatrix3 } from '@0b5vr/experimental/math/mat3/RawMatrix3';
    import type { RawVector4 } from '@0b5vr/experimental/math/vec4/RawVector4';
    /**
      * Apply a vec4 a mat3 (with an implicit 1 on m44).
      */
    export function vec4ApplyMatrix3(v: RawVector4, m: RawMatrix3): RawVector4;
}

declare module '@0b5vr/experimental/math/vec4/vec4ApplyMatrix4' {
    import type { RawMatrix4 } from '@0b5vr/experimental/math/mat4';
    import type { RawVector4 } from '@0b5vr/experimental/math/vec4/RawVector4';
    /**
      * Multiply a vec4 by a mat4.
      */
    export function vec4ApplyMatrix4(v: RawVector4, m: RawMatrix4): RawVector4;
}

declare module '@0b5vr/experimental/math/vec4/Vector4' {
    import { Matrix4 } from '@0b5vr/experimental/math/mat4/Matrix4';
    import { Vector } from '@0b5vr/experimental/math/vec/Vector';
    import type { Matrix3 } from '@0b5vr/experimental/math/mat3/Matrix3';
    import type { RawVector4 } from '@0b5vr/experimental/math/vec4/RawVector4';
    /**
        * A Vector3.
        */
    export class Vector4 extends Vector<Vector4> {
            elements: RawVector4;
            constructor(v?: RawVector4);
            /**
                * An x component of this.
                */
            get x(): number;
            set x(x: number);
            /**
                * A y component of this.
                */
            get y(): number;
            set y(y: number);
            /**
                * A z component of this.
                */
            get z(): number;
            set z(z: number);
            /**
                * A w component of this.
                */
            get w(): number;
            set w(z: number);
            toString(): string;
            /**
                * Apply this vector a mat3 (with an implicit 1 on m44).
                */
            applyMatrix3(matrix: Matrix3): Vector4;
            /**
                * Multiply this vector by a mat4.
                */
            applyMatrix4(matrix: Matrix4): Vector4;
            protected __new(v: RawVector4): Vector4;
            /**
                * Vector4( 0.0, 0.0, 0.0, 0.0 )
                */
            static get zero(): Vector4;
            /**
                * Vector4( 1.0, 1.0, 1.0, 1.0 )
                */
            static get one(): Vector4;
    }
}

