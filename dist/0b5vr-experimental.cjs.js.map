{
  "version": 3,
  "sources": ["../src/index.ts", "../src/algorithm/binarySearch.ts", "../src/algorithm/traverse.ts", "../src/array/arrayRange.ts", "../src/array/arraySerial.ts", "../src/array/arraySet.ts", "../src/array/constants.ts", "../src/array/utils.ts", "../src/CDS/CDS.ts", "../src/Clock/Clock.ts", "../src/Clock/ClockFrame.ts", "../src/Clock/ClockRealtime.ts", "../src/color/colorFromAtariST.ts", "../src/math/utils.ts", "../src/color/colorHSV2RGB.ts", "../src/color/colorToHex.ts", "../src/math/vec/vecDot.ts", "../src/color/colorTurbo.ts", "../src/color/eotfRec709.ts", "../src/color/oetfRec709.ts", "../src/dag/dagEdgesParents.ts", "../src/dag/dagEdgesAncestors.ts", "../src/dag/dagEdgesChildren.ts", "../src/dag/dagEdgesDescendants.ts", "../src/dag/dagEdgesParent.ts", "../src/dag/dagEdgesResolve.ts", "../src/edt/edt.ts", "../src/ExpSmooth/ExpSmooth.ts", "../src/Pool/Pool.ts", "../src/GPUTimer/GPUTimer.ts", "../src/HistoryMeanCalculator/HistoryMeanCalculator.ts", "../src/HistoryMeanCalculator/HistoryPercentileCalculator.ts", "../src/HistoryMeanCalculator/HistoryMedianCalculator.ts", "../src/MapOfSet/MapOfSet.ts", "../src/math/vec/vecAbs.ts", "../src/math/vec/vecAdd.ts", "../src/math/vec/vecDivide.ts", "../src/math/vec/vecLength.ts", "../src/math/vec/vecLengthSq.ts", "../src/math/vec/vecManhattanLength.ts", "../src/math/vec/vecMultiply.ts", "../src/math/vec/vecNeg.ts", "../src/math/vec/vecScale.ts", "../src/math/vec/vecNormalize.ts", "../src/math/vec/vecSub.ts", "../src/math/vec/Vector.ts", "../src/math/vec4/vec4ApplyMatrix4.ts", "../src/math/vec3/vec3ApplyMatrix4.ts", "../src/math/quat/quatInverse.ts", "../src/math/quat/quatMultiply.ts", "../src/math/vec3/vec3ApplyQuaternion.ts", "../src/math/vec3/vec3Cross.ts", "../src/math/vec3/vec3OrthoNormalize.ts", "../src/math/vec3/Vector3.ts", "../src/math/box3/box3ContainsPoint.ts", "../src/math/box3/Box3.ts", "../src/math/mat3/mat3FromMat4Transpose.ts", "../src/math/mat3/mat3Inverse.ts", "../src/math/mat3/mat3CreateNormalMatrix.ts", "../src/math/mat3/mat3Determinant.ts", "../src/math/mat3/mat3FromMat4.ts", "../src/math/mat3/mat3FromQuaternion.ts", "../src/math/mat3/mat3Multiply.ts", "../src/math/mat3/mat3Transpose.ts", "../src/math/mat3/Matrix3.ts", "../src/math/mat4/mat4FromQuaternion.ts", "../src/math/mat4/mat4Compose.ts", "../src/math/mat4/mat4Determinant.ts", "../src/math/quat/quatFromMatrix3.ts", "../src/math/quat/quatFromMatrix4.ts", "../src/math/mat4/mat4Decompose.ts", "../src/math/mat4/mat4FromMat3.ts", "../src/math/mat4/mat4Inverse.ts", "../src/math/mat4/mat4LookAt.ts", "../src/math/mat4/mat4LookAtInverse.ts", "../src/math/mat4/mat4Multiply.ts", "../src/math/mat4/mat4Perspective.ts", "../src/math/mat4/mat4RotationX.ts", "../src/math/mat4/mat4RotationY.ts", "../src/math/mat4/mat4RotationZ.ts", "../src/math/mat4/mat4Scale.ts", "../src/math/mat4/mat4ScaleScalar.ts", "../src/math/mat4/mat4Translate.ts", "../src/math/mat4/mat4Transpose.ts", "../src/math/mat4/Matrix4.ts", "../src/math/quat/quatFromAxisAngle.ts", "../src/math/quat/quatLookRotation.ts", "../src/math/quat/quatNormalize.ts", "../src/math/quat/quatRotationX.ts", "../src/math/quat/quatRotationY.ts", "../src/math/quat/quatRotationZ.ts", "../src/math/quat/quatSlerp.ts", "../src/math/quat/Quaternion.ts", "../src/math/mod.ts", "../src/math/sanitizeAngle.ts", "../src/math/euler/eulerFromMat3.ts", "../src/math/euler/eulerFromMat4.ts", "../src/math/euler/eulerFromQuaternion.ts", "../src/math/quat/quatFromEuler.ts", "../src/math/euler/Euler.ts", "../src/math/ray3/ray3DistanceToSphere.ts", "../src/math/line3/line3Delta.ts", "../src/math/ray3/ray3FromLine3.ts", "../src/math/ray3/Ray3.ts", "../src/math/line3/line3ApplyMatrix4.ts", "../src/math/line3/line3At.ts", "../src/math/line3/line3ClosestPointToPoint.ts", "../src/math/line3/line3DistanceToPoint.ts", "../src/math/line3/Line3.ts", "../src/math/mat2/mat2Determinant.ts", "../src/math/mat2/mat2Inverse.ts", "../src/math/mat2/mat2Multiply.ts", "../src/math/mat2/mat2Transpose.ts", "../src/math/mat2/Matrix2.ts", "../src/math/vec3/vec3ApplyMatrix3.ts", "../src/math/plane3/plane3ApplyMatrix4.ts", "../src/math/plane3/plane3DistanceToPoint.ts", "../src/math/plane3/plane3Normalize.ts", "../src/math/plane3/Plane3.ts", "../src/math/plane3/planes3ContainPoint.ts", "../src/math/plane3/planes3FromBox3.ts", "../src/math/plane3/planes3FromProjectionMatrix.ts", "../src/math/plane3/planes3IntersectBox3.ts", "../src/math/plane3/planes3IntersectSphere3.ts", "../src/math/plane3/Planes3.ts", "../src/math/sphere3/sphere3ContainsPoint.ts", "../src/math/sphere3/Sphere3.ts", "../src/math/vec4/vec4ApplyMatrix3.ts", "../src/math/vec4/Vector4.ts", "../src/midi/midiParse.ts", "../src/poker/pokerRanksByStrength.ts", "../src/poker/pokerSuitsByIndex.ts", "../src/poker/createPokerDeck.ts", "../src/poker/pokerHandStrengthMap.ts", "../src/poker/pokerRankStrengthMap.ts", "../src/poker/pokerSuitIndexMap.ts", "../src/poker/sortPokerCardsByRank.ts", "../src/poker/evaluatePokerHand.ts", "../src/poker/pokerHandsByStrength.ts", "../src/retry/asyncRetry.ts", "../src/retry/retry.ts", "../src/stniccc/parseSTNICCC.ts", "../src/stniccc/stnicccToSVG.ts", "../src/SmoothDamp/SmoothDamp.ts", "../src/Swap/Swap.ts", "../src/TapTempo/TapTempo.ts", "../src/tinyseq/createTinyseqPolyReader.ts", "../src/tinyseq/createTinyseqReader.ts", "../src/tinyseq/tinyseqFromMidiParseResult.ts", "../src/Xorshift/Xorshift.ts", "../src/yugop/getYugopText.ts", "../src/BinaryHeap.ts", "../src/debounce.ts", "../src/notifyObservers.ts", "../src/throttle.ts"],
  "sourcesContent": ["export * from './algorithm';\nexport * from './array';\nexport * from './CDS';\nexport * from './Clock';\nexport * from './color';\nexport * from './dag';\nexport * from './edt';\nexport * from './ExpSmooth';\n\n// This is somehow very not treeshaking friendly so removing\n// export * from './FizzBuzz';\n\nexport * from './GPUTimer';\nexport * from './HistoryMeanCalculator';\nexport * from './MapOfSet';\nexport * from './math';\nexport * from './midi';\nexport * from './poker';\nexport * from './Pool';\nexport * from './retry';\nexport * from './stniccc';\nexport * from './SmoothDamp';\nexport * from './Swap';\nexport * from './TapTempo';\nexport * from './tinyseq';\nexport * from './Xorshift';\nexport * from './yugop';\n\nexport * from './BinaryHeap';\nexport { debounce } from './debounce';\nexport { Observer, notifyObservers } from './notifyObservers';\nexport { throttle } from './throttle';\n", "// yoinked from https://stackoverflow.com/questions/1344500/efficient-way-to-insert-a-number-into-a-sorted-array-of-numbers\n\n/**\n * Look for an index from a sorted list using binary search.\n *\n * If you don't provide a compare function, it will look for **the first same value** it can find.\n * If it cannot find an exactly matching value, it can return N where the length of given array is N.\n *\n * @param array A sorted array\n * @param compare Make this function return `false` if you want to point right side of given element, `true` if you want to point left side of given element.\n * @returns An index found\n */\nexport function binarySearch<T>( array: ArrayLike<T>, element: T ): number;\nexport function binarySearch<T>( array: ArrayLike<T>, compare: ( element: T ) => boolean ): number;\nexport function binarySearch<T>(\n  array: ArrayLike<T>,\n  elementOrCompare: T | ( ( element: T ) => boolean ),\n): number {\n  if ( typeof elementOrCompare !== 'function' ) {\n    return binarySearch( array, ( element ) => ( element < elementOrCompare ) );\n  }\n  const compare = elementOrCompare as ( element: T ) => boolean;\n\n  let start = 0;\n  let end = array.length;\n\n  while ( start < end ) {\n    const center = ( start + end ) >> 1;\n    const centerElement = array[ center ];\n\n    const compareResult = compare( centerElement );\n\n    if ( compareResult ) {\n      start = center + 1;\n    } else {\n      end = center;\n    }\n  }\n\n  return start;\n}\n", "/**\n * Generic traverse function.\n *\n * It performs Depth-First Search.\n *\n * The `traverser` function will be executed for each descendants.\n * You need to return their \"children\" in an array.\n * If you want to stop the traversal, return `false` instead.\n *\n * @example\n * ```js\n * // replicate Three.js traverse for no reason\n * const meshes = [];\n * traverse( object3DRoot, ( object ) => {\n *   if ( object.isMesh ) {\n *     meshes.push( object );\n *   }\n *   return object3DRoot.children;\n * } );\n * ```\n *\n * @param root The \"root\" node\n * @param traverser The traverse function. If the node has \"children\" return them in an array.\n */\nexport function traverse<TNode>(\n  root: TNode,\n  traverser: ( node: TNode ) => TNode[] | false,\n): void {\n  const nodesNeedProcess: TNode[] = [ root ];\n  const nodesSeen = new Set<TNode>( nodesNeedProcess );\n\n  while ( nodesNeedProcess.length > 0 ) {\n    const currentNode = nodesNeedProcess.shift()!;\n\n    const children = traverser( currentNode );\n\n    if ( !children ) {\n      break;\n    }\n\n    const nodesFound = children.filter( ( node ) => !nodesSeen.has( node ) );\n    nodesNeedProcess.unshift( ...nodesFound );\n    nodesFound.map( ( node ) => nodesSeen.add( node ) );\n  }\n}\n", "export function arrayRange( start: number, end: number, step?: number ): number[] {\n  let current = start;\n  const ret: number[] = [];\n\n  if ( start < end ) {\n    step = step ?? 1;\n    while ( current < end ) {\n      ret.push( current );\n      current += step;\n    }\n  } else {\n    step = step ?? -1;\n    while ( current > end ) {\n      ret.push( current );\n      current += step;\n    }\n  }\n\n  return ret;\n}\n\n", "export const arraySerial = ( count: number ): number[] => (\n  [ ...Array( count ) ].map( ( _, i ) => i )\n);\n", "export function arraySetDelete<T>( array: Array<T>, value: T ): boolean {\n  const index = array.indexOf( value );\n  if ( index === -1 ) { return false; }\n\n  array.splice( index, 1 );\n  return true;\n}\n\nexport function arraySetHas<T>( array: Array<T>, value: T ): boolean {\n  return array.indexOf( value ) !== -1;\n}\n\nexport function arraySetAdd<T>( array: Array<T>, value: T ): boolean {\n  const index = array.indexOf( value );\n  if ( index !== -1 ) { return false; }\n\n  array.push( value );\n  return true;\n}\n\nexport function arraySetUnion<T>( a: Array<T>, b: Array<T> ): Array<T> {\n  const out = [ ...a ];\n  b.forEach( ( v ) => {\n    if ( !arraySetHas( out, v ) ) {\n      out.push( v );\n    }\n  } );\n  return out;\n}\n\nexport function arraySetDiff<T>( from: Array<T>, diff: Array<T> ): Array<T> {\n  const out = [ ...from ];\n  diff.forEach( ( v ) => {\n    arraySetDelete( out, v );\n  } );\n  return out;\n}\n", "/**\n * `[ -1, -1, 1, -1, -1, 1, 1, 1 ]`\n */\nexport const TRIANGLE_STRIP_QUAD = [ -1, -1, 1, -1, -1, 1, 1, 1 ];\n\n/**\n * `[ -1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0 ]`\n */\nexport const TRIANGLE_STRIP_QUAD_3D = [ -1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0 ];\n\n/**\n * `[ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]`\n */\nexport const TRIANGLE_STRIP_QUAD_NORMAL = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ];\n\n/**\n * `[ 0, 0, 1, 0, 0, 1, 1, 1 ]`\n */\nexport const TRIANGLE_STRIP_QUAD_UV = [ 0, 0, 1, 0, 0, 1, 1, 1 ];\n", "/**\n * Shuffle given `array` using given `dice` RNG. **Destructive**.\n */\nexport function shuffleArray<T>( array: T[], dice?: () => number ): T[] {\n  const f = dice ? dice : () => Math.random();\n  for ( let i = 0; i < array.length - 1; i ++ ) {\n    const ir = i + Math.floor( f() * ( array.length - i ) );\n    const temp = array[ ir ];\n    array[ ir ] = array[ i ];\n    array[ i ] = temp;\n  }\n  return array;\n}\n\n/**\n * I like wireframe\n *\n * `triIndexToLineIndex( [ 0, 1, 2, 5, 6, 7 ] )` -> `[ 0, 1, 1, 2, 2, 0, 5, 6, 6, 7, 7, 5 ]`\n */\nexport function triIndexToLineIndex<T>( array: T[] ): T[] {\n  const ret: T[] = [];\n  for ( let i = 0; i < array.length / 3; i ++ ) {\n    const head = i * 3;\n    ret.push(\n      array[ head     ], array[ head + 1 ],\n      array[ head + 1 ], array[ head + 2 ],\n      array[ head + 2 ], array[ head     ]\n    );\n  }\n  return ret;\n}\n\n/**\n * `matrix2d( 3, 2 )` -> `[ 0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2 ]`\n */\nexport function matrix2d( w: number, h: number ): number[] {\n  const arr: number[] = [];\n  for ( let iy = 0; iy < h; iy ++ ) {\n    for ( let ix = 0; ix < w; ix ++ ) {\n      arr.push( ix, iy );\n    }\n  }\n  return arr;\n}\n\n/**\n * See also: {@link matrix2d}\n */\nexport function matrix3d( w: number, h: number, d: number ): number[] {\n  const arr: number[] = [];\n  for ( let iz = 0; iz < d; iz ++ ) {\n    for ( let iy = 0; iy < h; iy ++ ) {\n      for ( let ix = 0; ix < w; ix ++ ) {\n        arr.push( ix, iy, iz );\n      }\n    }\n  }\n  return arr;\n}\n", "/**\n * Critically Damped Spring\n *\n * Shoutouts to Keijiro Takahashi\n */\nexport class CDS {\n  public factor = 100.0;\n  public ratio = 1.0;\n  public velocity = 0.0;\n  public value = 0.0;\n  public target = 0.0;\n\n  public update( deltaTime: number ): number {\n    this.velocity += (\n      -this.factor * ( this.value - this.target )\n      - 2.0 * this.velocity * Math.sqrt( this.factor ) * this.ratio\n    ) * deltaTime;\n    this.value += this.velocity * deltaTime;\n    return this.value;\n  }\n}\n", "/**\n * Class that deals with time.\n * In this base class, you need to set time manually from `Automaton.update()`.\n * Best for sync with external clock stuff.\n */\nexport class Clock {\n  /**\n   * Its current time.\n   */\n  protected __time = 0.0;\n\n  /**\n   * Its deltaTime of last update.\n   */\n  protected __deltaTime = 0.0;\n\n  /**\n   * Whether its currently playing or not.\n   */\n  protected __isPlaying = false;\n\n  /**\n   * Its current time.\n   */\n  public get time(): number { return this.__time; }\n\n  /**\n   * Its deltaTime of last update.\n   */\n  public get deltaTime(): number { return this.__deltaTime; }\n\n  /**\n   * Whether its currently playing or not.\n   */\n  public get isPlaying(): boolean { return this.__isPlaying; }\n\n  /**\n   * Update the clock.\n   * @param time Time. You need to set manually when you are using manual Clock\n   */\n  public update( time?: number ): void {\n    const prevTime = this.__time;\n    this.__time = time || 0.0;\n    this.__deltaTime = this.__time - prevTime;\n  }\n\n  /**\n   * Start the clock.\n   */\n  public play(): void {\n    this.__isPlaying = true;\n  }\n\n  /**\n   * Stop the clock.\n   */\n  public pause(): void {\n    this.__isPlaying = false;\n  }\n\n  /**\n   * Set the time manually.\n   * @param time Time\n   */\n  public setTime( time: number ): void {\n    this.__time = time;\n  }\n}\n", "import { Clock } from './Clock';\n\n/**\n * Class that deals with time.\n * This is \"frame\" type clock, the frame increases every {@link ClockFrame#update} call.\n * @param fps Frames per second\n */\nexport class ClockFrame extends Clock {\n  /**\n   * Its current frame.\n   */\n  private __frame = 0;\n\n  /**\n   * Its fps.\n   */\n  private __fps: number;\n\n  public constructor( fps = 60 ) {\n    super();\n    this.__fps = fps;\n  }\n\n  /**\n   * Its current frame.\n   */\n  public get frame(): number { return this.__frame; }\n\n  /**\n   * Its fps.\n   */\n  public get fps(): number { return this.__fps; }\n\n  /**\n   * Update the clock. It will increase the frame by 1.\n   */\n  public update(): void {\n    if ( this.__isPlaying ) {\n      this.__time = this.__frame / this.__fps;\n      this.__deltaTime = 1.0 / this.__fps;\n      this.__frame ++;\n    } else {\n      this.__deltaTime = 0.0;\n    }\n  }\n\n  /**\n   * Set the time manually.\n   * The set time will be converted into internal frame count, so the time will not be exactly same as set one.\n   * @param time Time\n   */\n  public setTime( time: number ): void {\n    this.__frame = Math.floor( this.__fps * time );\n    this.__time = this.__frame / this.__fps;\n  }\n}\n", "import { Clock } from './Clock';\n\n/**\n * Class that deals with time.\n * This is \"realtime\" type clock, the time goes on as real world.\n */\nexport class ClockRealtime extends Clock {\n  /**\n   * \"You set the time manually to `__rtTime` when it's `__rtDate`.\"\n   */\n  private __rtTime = 0.0;\n\n  /**\n   * \"You set the time manually to `__rtTime` when it's `__rtDate`.\"\n   */\n  private __rtDate: number = performance.now();\n\n  /**\n   * The clock is realtime. yeah.\n   */\n  public get isRealtime(): boolean { return true; }\n\n  /**\n   * Update the clock. Time is calculated based on time in real world.\n   */\n  public update(): void {\n    const now = performance.now();\n\n    if ( this.__isPlaying ) {\n      const prevTime = this.__time;\n      const deltaDate = ( now - this.__rtDate );\n      this.__time = this.__rtTime + deltaDate / 1000.0;\n      this.__deltaTime = this.time - prevTime;\n    } else {\n      this.__rtTime = this.time;\n      this.__rtDate = now;\n      this.__deltaTime = 0.0;\n    }\n  }\n\n  /**\n   * Set the time manually.\n   * @param time Time\n   */\n  public setTime( time: number ): void {\n    this.__time = time;\n    this.__rtTime = this.time;\n    this.__rtDate = performance.now();\n  }\n}\n", "import type { RawRGB } from './RawRGB';\n\n/**\n * Converts the input color in Atari-ST color palette format to a {@link RawRGB}.\n *\n * @param stColor A color in Atari-ST format\n */\nexport function colorFromAtariST( stColor: number ): RawRGB {\n  return [\n    ( stColor >> 8 & 7 ) / 7.0,\n    ( stColor >> 4 & 7 ) / 7.0,\n    ( stColor & 7 ) / 7.0,\n  ];\n}\n", "/**\n * `lerp`, or `mix`\n */\nexport function lerp( a: number, b: number, x: number ): number {\n  return a + ( b - a ) * x;\n}\n\n/**\n * `clamp`\n */\nexport function clamp( x: number, l: number, h: number ): number {\n  return Math.min( Math.max( x, l ), h );\n}\n\n/**\n * `clamp( x, 0.0, 1.0 )`\n */\nexport function saturate( x: number ): number {\n  return clamp( x, 0.0, 1.0 );\n}\n\n/**\n * Transform a value from input range to output range.\n */\nexport function range( x: number, x0: number, x1: number, y0: number, y1: number ): number {\n  return ( ( x - x0 ) * ( y1 - y0 ) / ( x1 - x0 ) + y0 );\n}\n\n/**\n * `smoothstep` but not smooth\n */\nexport function linearstep( a: number, b: number, x: number ): number {\n  return saturate( ( x - a ) / ( b - a ) );\n}\n\n/**\n * world famous `smoothstep` function\n */\nexport function smoothstep( a: number, b: number, x: number ): number {\n  const t = linearstep( a, b, x );\n  return t * t * ( 3.0 - 2.0 * t );\n}\n\n/**\n * `smoothstep` but more smooth\n */\nexport function smootherstep( a: number, b: number, x: number ): number {\n  const t = linearstep( a, b, x );\n  return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n}\n\n/**\n * `smoothstep` but WAY more smooth\n */\nexport function smootheststep( a: number, b: number, x: number ): number {\n  const t = linearstep( a, b, x );\n  return t * t * t * t * ( t * ( t * ( -20.0 * t + 70.0 ) - 84.0 ) + 35.0 );\n}\n", "import { RawRGB } from './RawRGB';\nimport { lerp } from '../math/utils';\n\n/**\n * Convert a color from HSV to RGB.\n * Each component of the HSV must be given in [0 - 1] range.\n *\n * Ref: https://en.wikipedia.org/wiki/HSV_color_space\n */\nexport function colorHSV2RGB( [ h, s, v ]: [ number, number, number ] ): RawRGB {\n  const ht = h % 1.0 * 6.0;\n\n  return [ 0.0, 4.0, 2.0 ].map( ( p ) => {\n    const colH = Math.min( Math.max( (\n      Math.abs( ( ht + p ) % 6.0 - 3.0 ) - 1.0\n    ), 0.0 ), 1.0 );\n    const colS = lerp( 1.0, colH, s );\n    return v * colS;\n  } ) as RawRGB;\n}\n", "import { saturate } from '../math/utils';\nimport type { RawRGB } from './RawRGB';\n\n/**\n * Converts the input color to hex representation (e.g. #7f7f7f)\n * @param color color in {@link RawRGB}\n */\nexport function colorToHex( color: RawRGB ): string {\n  return '#' + color.map( ( v ) => (\n    ( '0' + ( Math.round( saturate( v ) * 255.0 ) ).toString( 16 ) ).slice( -2 )\n  ) ).join( '' );\n}\n", "/**\n * Return a dot product of given two vectors.\n */\nexport function vecDot<T extends number[]>( vecA: T, vecB: T ): number {\n  return vecA.reduce( ( sum, v, i ) => sum + v * vecB[ i ], 0.0 );\n}\n", "/*!\n * Turbo colormap\n *\n * Copyright 2019 Google LLC. (Apache-2.0)\n *\n * https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7\n */\n\nimport { RawRGB } from './RawRGB';\nimport { saturate } from '../math/utils';\nimport { vecDot } from '../math/vec/vecDot';\n\n/**\n * Generate a turbo gradient.\n *\n * Ref: https://gist.github.com/mikhailov-work/0d177465a8151eb6ede1768d51d476c7\n */\nexport function colorTurbo( x: number ): RawRGB {\n  const kr = [\n    0.13572138, 4.61539260, -42.66032258,\n    132.13108234, -152.94239396, 59.28637943,\n  ];\n  const kg = [\n    0.09140261, 2.19418839, 4.84296658,\n    -14.18503333, 4.27729857, 2.82956604,\n  ];\n  const kb = [\n    0.10667330, 12.64194608, -60.58204836,\n    110.36276771, -89.90310912, 27.34824973,\n  ];\n\n  const xt = saturate( x );\n  const xv = [\n    1.0,\n    xt,\n    xt * xt,\n    xt * xt * xt,\n    xt * xt * xt * xt,\n    xt * xt * xt * xt * xt,\n  ];\n\n  const col = [\n    saturate( vecDot( kr, xv ) ),\n    saturate( vecDot( kg, xv ) ),\n    saturate( vecDot( kb, xv ) ),\n  ];\n\n  return col as RawRGB;\n}\n", "import type { RawRGB } from './RawRGB';\n\n/**\n * EOTF of Rec.709 a.k.a. sRGB-to-Linear\n */\nexport function eotfRec709( value: RawRGB ): RawRGB {\n  return value.map( ( v ) => (\n    v < 0.081\n      ? v / 4.5\n      : Math.pow( ( v + 0.099 ) / 1.099, 1.0 / 0.45 )\n  ) ) as RawRGB;\n}\n", "import type { RawRGB } from './RawRGB';\n\n/**\n * OETF of Rec.709 a.k.a. Linear-to-sRGB\n */\nexport function oetfRec709( luminance: RawRGB ): RawRGB {\n  return luminance.map( ( l ) => (\n    l < 0.018\n      ? 4.5 * l\n      : 1.099 * Math.pow( l, 0.45 ) - 0.099\n  ) ) as RawRGB;\n}\n", "import { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all parent sources the specified destination has.\n * @param edges An array of dag edge\n * @param destination The target destination\n *\n * See also: {@link dagEdgesChildren}\n */\nexport function dagEdgesParents<T>( edges: RawDagEdge<T>[], destination: T ): T[] {\n  return edges\n    .filter( ( edge ) => edge[ 1 ] === destination )\n    .map( ( edge ) => edge[ 0 ] );\n}\n", "import { dagEdgesParents } from './dagEdgesParents';\nimport { traverse } from '../algorithm/traverse';\nimport type { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all ancestor sources the specified destination has.\n * @param edges An array of dag edge\n * @param destination The target destination\n *\n * See also: {@link dagEdgesChildren}\n */\nexport function dagEdgesAncestors<T>( edges: RawDagEdge<T>[], destination: T ): T[] {\n  const ancestors = new Set<T>();\n\n  traverse( destination, ( node ) => {\n    const parents = dagEdgesParents( edges, node );\n    parents.map( ( parent ) => ancestors.add( parent ) );\n    return parents;\n  } );\n\n  return Array.from( ancestors );\n}\n", "import { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all children destinations the specified source has.\n * @param edges An array of dag edge\n * @param source The target source\n *\n * See also: {@link dagEdgesDescendant}\n */\nexport function dagEdgesChildren<T>( edges: RawDagEdge<T>[], source: T ): T[] {\n  return edges\n    .filter( ( edge ) => edge[ 0 ] === source )\n    .map( ( edge ) => edge[ 1 ] );\n}\n", "import { dagEdgesChildren } from './dagEdgesChildren';\nimport { traverse } from '../algorithm/traverse';\nimport type { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return all descendant destinations the specified source has.\n * @param edges An array of dag edge\n * @param source The target source\n *\n * See also: {@link dagEdgesChildren}\n */\nexport function dagEdgesDescendants<T>( edges: RawDagEdge<T>[], source: T ): T[] {\n  const descendants = new Set<T>();\n\n  traverse( source, ( node ) => {\n    const children = dagEdgesChildren( edges, node );\n    children.map( ( child ) => descendants.add( child ) );\n    return children;\n  } );\n\n  return Array.from( descendants );\n}\n", "import { RawDagEdge } from './RawDagEdge';\n\n/**\n * Return first parent source the specified destination has.\n * If it can't find a parent, it will return `null` instead.\n *\n * @param edges An array of dag edge\n * @param destination The target destination\n *\n * See also: {@link dagEdgesParents}\n */\nexport function dagEdgesParent<T>( edges: RawDagEdge<T>[], destination: T ): T | null {\n  return edges.find( ( edge ) => edge[ 1 ] === destination )?.[ 0 ] ?? null;\n}\n", "import { RawDagEdge } from './RawDagEdge';\nimport { dagEdgesParent } from './dagEdgesParent';\n\n/**\n * Resolve dag dependency relationship and give you a correct order.\n *\n * @param edges An array of dag edges\n * @param nodes An array of dag nodes\n */\nexport function dagEdgesResolve<T>( edges: RawDagEdge<T>[], nodes: T[] ): T[] {\n  const order: T[] = [];\n\n  const nodeSet = new Set( nodes );\n  let tempEdges = edges.concat();\n\n  while ( tempEdges.length > 0 ) {\n    nodeSet.forEach( ( node ) => {\n      // is this an entrypoint?\n      const hasParents = dagEdgesParent( tempEdges, node ) != null;\n\n      if ( !hasParents ) {\n        nodeSet.delete( node );\n        order.push( node );\n\n        // delete the structure of tempEdges from entrypoint side\n        tempEdges = tempEdges.filter( ( [ src ] ) => ( src !== node ) );\n      }\n    } );\n  }\n\n  return order.concat( Array.from( nodeSet ) );\n  //                   ^^^^^^^^^^^^^^^^^^^^^ terminator nodes\n}\n", "// yoinked from https://github.com/mapbox/tiny-sdf (BSD 2-Clause)\n// implements http://people.cs.uchicago.edu/~pff/papers/dt.pdf\n\n/**\n * Compute a one dimensional edt from the source data.\n * Returning distance will be squared.\n * Intended to be used internally in {@link edt2d}.\n *\n * @param data Data of the source\n * @param offset Offset of the source from beginning\n * @param stride Stride of the source\n * @param length Length of the source\n */\nexport function edt1d(\n  data: Float32Array,\n  offset: number,\n  stride: number,\n  length: number\n): void {\n  // index of rightmost parabola in lower envelope\n  let k = 0;\n\n  // locations of parabolas in lower envelope\n  const v = new Float32Array( length );\n  v[ 0 ] = 0.0;\n\n  // locations of boundaries between parabolas\n  const z = new Float32Array( length + 1 );\n  z[ 0 ] = -Infinity;\n  z[ 1 ] = Infinity;\n\n  // create a straight array of input data\n  const f = new Float32Array( length );\n  for ( let q = 0; q < length; q ++ ) {\n    f[ q ] = data[ offset + q * stride ];\n  }\n\n  // compute lower envelope\n  for ( let q = 1; q < length; q ++ ) {\n    let s = 0.0;\n\n    while ( 0 <= k ) {\n      s = ( f[ q ] + q * q - f[ v[ k ] ] - v[ k ] * v[ k ] ) / ( 2.0 * q - 2.0 * v[ k ] );\n      if ( s <= z[ k ] ) {\n        k --;\n      } else {\n        break;\n      }\n    }\n\n    k ++;\n    v[ k ] = q;\n    z[ k ] = s;\n    z[ k + 1 ] = Infinity;\n  }\n\n  k = 0;\n\n  // fill in values of distance transform\n  for ( let q = 0; q < length; q ++ ) {\n    while ( z[ k + 1 ] < q ) { k ++; }\n    const qSubVK = q - v[ k ];\n    data[ offset + q * stride ] = f[ v[ k ] ] + qSubVK * qSubVK;\n  }\n}\n\n/**\n * Compute a two dimensional edt from the source data.\n * Returning distance will be squared.\n *\n * @param data Data of the source.\n * @param width Width of the source.\n * @param height Height of the source.\n */\nexport function edt2d(\n  data: Float32Array,\n  width: number,\n  height: number\n): void {\n  for ( let x = 0; x < width; x ++ ) {\n    edt1d( data, x, width, height );\n  }\n\n  for ( let y = 0; y < height; y ++ ) {\n    edt1d( data, y * width, 1, width );\n  }\n}\n", "import { lerp } from '../math/utils';\n\n/**\n * Do exp smoothing\n */\nexport class ExpSmooth {\n  public factor = 10.0;\n  public target = 0.0;\n  public value = 0.0;\n\n  public update( deltaTime: number ): number {\n    this.value = lerp( this.target, this.value, Math.exp( -this.factor * deltaTime ) );\n    return this.value;\n  }\n}\n", "export class Pool<T> {\n  public array: T[];\n\n  public index = 0;\n\n  public get current(): T {\n    return this.array[ this.index ];\n  }\n\n  public constructor( array: T[] ) {\n    this.array = array;\n  }\n\n  public next(): T {\n    this.index = ( this.index + 1 ) % this.array.length;\n    return this.current;\n  }\n}\n", "import { Pool } from '../Pool/Pool';\n\nexport class GPUTimer {\n  public queries: Pool<WebGLQuery>;\n  public stack: Promise<number>[];\n  public ext: any;\n  public readonly gl: WebGL2RenderingContext;\n\n  private __loopTasks: Set<() => void>;\n\n  public static isSupported( gl: WebGLRenderingContext | WebGL2RenderingContext ): boolean {\n    return new Set( gl.getSupportedExtensions() ).has( 'EXT_disjoint_timer_query_webgl2' );\n  }\n\n  public constructor( gl: WebGL2RenderingContext ) {\n    this.gl = gl;\n\n    const queries = new Array( 1024 ).fill( 1 ).map( () => gl.createQuery()! );\n    this.queries = new Pool( queries );\n\n    this.stack = [];\n\n    this.ext = gl.getExtension( 'EXT_disjoint_timer_query_webgl2' );\n\n    this.__loopTasks = new Set();\n\n    // loop\n    const update = (): void => {\n      this.update();\n      requestAnimationFrame( update );\n    };\n    update();\n  }\n\n  public update(): void {\n    Array.from( this.__loopTasks ).forEach( ( task ) => task() );\n  }\n\n  public async measure( func: () => void ): Promise<number> {\n    const { gl } = this;\n\n    if ( this.stack.length !== 0 ) {\n      gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n      const promiseFinishingPrev = this.check( this.queries.current );\n\n      this.stack = this.stack.map( async ( promiseAccum ) => {\n        return ( await promiseAccum ) + ( await promiseFinishingPrev );\n      } );\n    }\n\n    this.stack.push( Promise.resolve( 0.0 ) );\n\n    gl.beginQuery( this.ext.TIME_ELAPSED_EXT, this.queries.next() );\n\n    func();\n\n    gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n\n    const promiseAccum = this.stack.pop()!;\n    const promiseThis = this.check( this.queries.current );\n\n    if ( this.stack.length !== 0 ) {\n      this.stack = this.stack.map( async ( promiseAccum ) => {\n        return ( await promiseAccum ) + ( await promiseThis );\n      } );\n\n      gl.beginQuery( this.ext.TIME_ELAPSED_EXT, this.queries.next() );\n    }\n\n    return ( await promiseAccum ) + ( await promiseThis );\n  }\n\n  public check( query: WebGLQuery ): Promise<number> {\n    const { gl } = this;\n\n    return new Promise( ( resolve ) => {\n      const task = (): void => {\n        const isAvailable = gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE );\n\n        if ( isAvailable ) {\n          this.__loopTasks.delete( task );\n          resolve( gl.getQueryParameter( query, gl.QUERY_RESULT ) * 0.001 * 0.001 );\n        }\n      };\n\n      this.__loopTasks.add( task );\n    } );\n  }\n}\n", "/**\n * Useful for tap tempo\n * See also: {@link HistoryMeanCalculator}\n */\nexport class HistoryMeanCalculator {\n  private __recalcForEach = 0;\n  private __countUntilRecalc = 0;\n  private __history: number[] = [];\n  private __index = 0;\n  private __length: number;\n  private __count = 0;\n  private __cache = 0;\n\n  public constructor( length: number ) {\n    this.__length = length;\n    this.__recalcForEach = length;\n    for ( let i = 0; i < length; i ++ ) {\n      this.__history[ i ] = 0;\n    }\n  }\n\n  public get mean(): number {\n    const count = Math.min( this.__count, this.__length );\n    return count === 0 ? 0.0 : this.__cache / count;\n  }\n\n  public get recalcForEach(): number {\n    return this.__recalcForEach;\n  }\n\n  public set recalcForEach( value: number ) {\n    const delta = value - this.__recalcForEach;\n    this.__recalcForEach = value;\n    this.__countUntilRecalc = Math.max( 0, this.__countUntilRecalc + delta );\n  }\n\n  public reset(): void {\n    this.__index = 0;\n    this.__count = 0;\n    this.__cache = 0;\n    this.__countUntilRecalc = 0;\n    for ( let i = 0; i < this.__length; i ++ ) {\n      this.__history[ i ] = 0;\n    }\n  }\n\n  public push( value: number ): void {\n    const prev = this.__history[ this.__index ];\n    this.__history[ this.__index ] = value;\n    this.__count ++;\n    this.__index = ( this.__index + 1 ) % this.__length;\n\n    if ( this.__countUntilRecalc === 0 ) {\n      this.recalc();\n    } else {\n      this.__countUntilRecalc --;\n      this.__cache -= prev;\n      this.__cache += value;\n    }\n  }\n\n  public recalc(): void {\n    this.__countUntilRecalc = this.__recalcForEach;\n    const sum = this.__history\n      .slice( 0, Math.min( this.__count, this.__length ) )\n      .reduce( ( sum, v ) => sum + v, 0 );\n    this.__cache = sum;\n  }\n}\n", "import { binarySearch } from '../algorithm/binarySearch';\n\n/**\n * Useful for fps calc\n * See also: {@link HistoryMeanCalculator}\n */\nexport class HistoryPercentileCalculator {\n  private __history: number[] = [];\n  private __sorted: number[] = [];\n  private __index = 0;\n  private readonly __length: number;\n\n  public constructor( length: number ) {\n    this.__length = length;\n  }\n\n  public get median(): number {\n    return this.percentile( 50.0 );\n  }\n\n  public percentile( percentile: number ): number {\n    if ( this.__history.length === 0 ) { return 0.0; }\n    return this.__sorted[ Math.round( percentile * 0.01 * ( this.__history.length - 1 ) ) ];\n  }\n\n  public reset(): void {\n    this.__index = 0;\n    this.__history = [];\n    this.__sorted = [];\n  }\n\n  public push( value: number ): void {\n    const prev = this.__history[ this.__index ];\n    this.__history[ this.__index ] = value;\n    this.__index = ( this.__index + 1 ) % this.__length;\n\n    // remove the prev from sorted array\n    if ( this.__sorted.length === this.__length ) {\n      const prevIndex = binarySearch( this.__sorted, prev );\n      this.__sorted.splice( prevIndex, 1 );\n    }\n\n    const index = binarySearch( this.__sorted, value );\n    this.__sorted.splice( index, 0, value );\n  }\n}\n", "import { HistoryPercentileCalculator } from './HistoryPercentileCalculator';\n\n/**\n * @deprecated It's actually just a special case of {@link HistoryPercentileCalculator}\n */\nexport class HistoryMedianCalculator extends HistoryPercentileCalculator {\n  public constructor( length: number ) {\n    super( length );\n    console.warn( 'HistoryMedianCalculator: Deprecated. Use HistoryPercentileCalculator instead' );\n  }\n}\n", "export class MapOfSet<K, V> {\n  public readonly map: Map<K, Set<V>>;\n\n  public constructor() {\n    this.map = new Map();\n  }\n\n  public get( key: K ): Set<V> {\n    return this.map.get( key ) ?? new Set();\n  }\n\n  public add( key: K, value: V ): void {\n    let set = this.map.get( key );\n    if ( set == null ) {\n      set = new Set();\n      this.map.set( key, set );\n    }\n    set.add( value );\n  }\n}\n", "/**\n * Return a vector with the absolute of each component of the given vector.\n */\nexport function vecAbs<T extends number[]>( vec: T ): T {\n  return vec.map( ( v ) => Math.abs( v ) ) as T;\n}\n", "/**\n * Return a sum of vectors.\n */\nexport function vecAdd<T extends number[]>( ...vecs: T[] ): T {\n  if ( vecs.length < 2 ) {\n    return vecs[ 0 ];\n  }\n\n  const a = vecs.shift()!;\n  const b = vecAdd( ...vecs );\n\n  return a.map( ( v, i ) => v + b[ i ] ) as T;\n}\n", "/**\n * Divide a vector by a vector.\n */\nexport function vecDivide<T extends number[]>( vecA: T, vecB: T ): T {\n  return vecA.map( ( v, i ) => v / vecB[ i ] ) as T;\n}\n", "/**\n * Return an euclidean length of given vector.\n */\nexport function vecLength<T extends number[]>( vec: T ): number {\n  return Math.sqrt( vec.reduce( ( sum, v ) => sum + v * v, 0.0 ) );\n}\n", "/**\n * Return an squared euclidean length of given vector.\n */\nexport function vecLengthSq<T extends number[]>( vec: T ): number {\n  return vec.reduce( ( sum, v ) => sum + v * v, 0.0 );\n}\n", "/**\n * Return a manhattan length of given vector.\n */\nexport function vecManhattanLength<T extends number[]>( vec: T ): number {\n  return vec.reduce( ( sum, v ) => sum + Math.abs( v ), 0.0 );\n}\n", "/**\n * Return a product of vectors.\n */\nexport function vecMultiply<T extends number[]>( ...vecs: T[] ): T {\n  if ( vecs.length < 2 ) {\n    return vecs[ 0 ];\n  }\n\n  const a = vecs.shift()!;\n  const b = vecMultiply( ...vecs );\n\n  return a.map( ( v, i ) => v * b[ i ] ) as T;\n}\n", "/**\n * Negate a vector.\n */\nexport function vecNeg<T extends number[]>( vec: T ): T {\n  return vec.map( ( v ) => -v ) as T;\n}\n", "/**\n * Scale the given vector by a scalar.\n */\nexport function vecScale<T extends number[]>( vec: T, scalar: number ): T {\n  return vec.map( ( v ) => v * scalar ) as T;\n}\n", "import { vecLength } from './vecLength';\nimport { vecScale } from './vecScale';\n\n/**\n * Normalize given vector.\n * If the length of given vector is 0.0, it will return a zero vector instead.\n */\nexport function vecNormalize<T extends number[]>( vec: T ): T {\n  const len = vecLength( vec );\n  const invLen = len === 0.0 ? 0.0 : 1.0 / len;\n  return vecScale( vec, invLen );\n}\n", "/**\n * Subtract a vector from a vector.\n */\nexport function vecSub<T extends number[]>( vecA: T, vecB: T ): T {\n  return vecA.map( ( v, i ) => v - vecB[ i ] ) as T;\n}\n", "import { vecAbs } from './vecAbs';\nimport { vecAdd } from './vecAdd';\nimport { vecDivide } from './vecDivide';\nimport { vecDot } from './vecDot';\nimport { vecLength } from './vecLength';\nimport { vecLengthSq } from './vecLengthSq';\nimport { vecManhattanLength } from './vecManhattanLength';\nimport { vecMultiply } from './vecMultiply';\nimport { vecNeg } from './vecNeg';\nimport { vecNormalize } from './vecNormalize';\nimport { vecScale } from './vecScale';\nimport { vecSub } from './vecSub';\n\n/**\n * A Vector.\n */\nexport abstract class Vector<T extends Vector<T>> {\n  public abstract elements: number[];\n\n  /**\n   * The length of this.\n   * a.k.a. `magnitude`\n   */\n  public get length(): number {\n    return vecLength( this.elements );\n  }\n\n  /**\n   * The squared length of this.\n   */\n  public get lengthSq(): number {\n    return vecLengthSq( this.elements );\n  }\n\n  /**\n   * The manhattan length of this.\n   */\n  public get manhattanLength(): number {\n    return vecManhattanLength( this.elements );\n  }\n\n  /**\n   * A normalized Vector3 of this.\n   */\n  public get normalized(): T {\n    return this.__new( vecNormalize( this.elements ) );\n  }\n\n  /**\n   * This but negated.\n   */\n  public get negated(): T {\n    return this.__new( vecNeg( this.elements ) );\n  }\n\n  /**\n   * This but each component is the absolute.\n   */\n  public get abs(): T {\n    return this.__new( vecAbs( this.elements ) );\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): T {\n    return this.__new( this.elements.concat() );\n  }\n\n  /**\n   * Add one or more Vector into this.\n   * @param vectors Other Vectors\n   */\n  public add( ...vectors: T[] ): T {\n    return this.__new( vecAdd( this.elements, ...vectors.map( ( v ) => v.elements ) ) );\n  }\n\n  /**\n   * Substract this from another Vector.\n   * @param v Another vector\n   */\n  public sub( vector: T ): T {\n    return this.__new( vecSub( this.elements, vector.elements ) );\n  }\n\n  /**\n   * Multiply one or more Vector with this.\n   * @param vectors Other Vectors\n   */\n  public multiply( ...vectors: T[] ): T {\n    return this.__new( vecMultiply( this.elements, ...vectors.map( ( v ) => v.elements ) ) );\n  }\n\n  /**\n   * Divide this from another Vector.\n   * @param vector Another Vector\n   */\n  public divide( vector: T ): T {\n    return this.__new( vecDivide( this.elements, vector.elements ) );\n  }\n\n  /**\n   * Scale this by scalar.\n   * a.k.a. `multiplyScalar`\n   * @param scalar A scalar\n   */\n  public scale( scalar: number ): T {\n    return this.__new( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * Dot two Vectors.\n   * @param vector Another vector\n   */\n  public dot( vector: T ): number {\n    return vecDot( this.elements, vector.elements );\n  }\n\n  protected abstract __new( v: number[] ): T;\n}\n", "import type { RawMatrix4 } from '../mat4';\nimport type { RawVector4 } from './RawVector4';\n\n/**\n * Multiply a vec4 by a mat4.\n */\nexport function vec4ApplyMatrix4( v: RawVector4, m: RawMatrix4 ): RawVector4 {\n  return [\n    m[ 0 ] * v[ 0 ] + m[ 4 ] * v[ 1 ] + m[ 8 ] * v[ 2 ] + m[ 12 ] * v[ 3 ],\n    m[ 1 ] * v[ 0 ] + m[ 5 ] * v[ 1 ] + m[ 9 ] * v[ 2 ] + m[ 13 ] * v[ 3 ],\n    m[ 2 ] * v[ 0 ] + m[ 6 ] * v[ 1 ] + m[ 10 ] * v[ 2 ] + m[ 14 ] * v[ 3 ],\n    m[ 3 ] * v[ 0 ] + m[ 7 ] * v[ 1 ] + m[ 11 ] * v[ 2 ] + m[ 15 ] * v[ 3 ],\n  ];\n}\n", "import { vec4ApplyMatrix4 } from '../vec4/vec4ApplyMatrix4';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Apply a vec3 (with an implicit 1 in the 4th dimension) a mat4.\n */\nexport function vec3ApplyMatrix4( v: RawVector3, m: RawMatrix4 ): RawVector3 {\n  const vec4 = vec4ApplyMatrix4( [ ...v, 1 ], m );\n  const xyz: RawVector3 = [ vec4[ 0 ], vec4[ 1 ], vec4[ 2 ] ];\n  const w = vec4[ 3 ];\n  return vecScale( xyz, 1.0 / w );\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Return an inverse of a quaternion.\n */\nexport function quatInverse( quat: RawQuaternion ): RawQuaternion {\n  return [ -quat[ 0 ], -quat[ 1 ], -quat[ 2 ], quat[ 3 ] ];\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Return a multiplication result of quaternions.\n */\nexport function quatMultiply( ...quats: RawQuaternion[] ): RawQuaternion {\n  if ( quats.length < 2 ) {\n    return quats[ 0 ];\n  }\n\n  const a = quats.shift()!;\n  const b = quatMultiply( ...quats );\n\n  return [\n    a[ 3 ] * b[ 0 ] + a[ 0 ] * b[ 3 ] + a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ],\n    a[ 3 ] * b[ 1 ] - a[ 0 ] * b[ 2 ] + a[ 1 ] * b[ 3 ] + a[ 2 ] * b[ 0 ],\n    a[ 3 ] * b[ 2 ] + a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] + a[ 2 ] * b[ 3 ],\n    a[ 3 ] * b[ 3 ] - a[ 0 ] * b[ 0 ] - a[ 1 ] * b[ 1 ] - a[ 2 ] * b[ 2 ],\n  ];\n}\n", "import { quatInverse } from '../quat/quatInverse';\nimport { quatMultiply } from '../quat/quatMultiply';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Apply a vec3 (with an implicit 1 in the 4th dimension) a quaternion.\n */\nexport function vec3ApplyQuaternion( vec: RawVector3, quat: RawQuaternion ): RawVector3 {\n  const p: RawQuaternion = [ ...vec, 0.0 ];\n  const r = quatInverse( quat );\n  const res = quatMultiply( quat, p, r );\n  res.pop();\n  return res as unknown as RawVector3;\n}\n", "import type { RawVector3 } from './RawVector3';\n\n/**\n * Return a cross product of two vec3s.\n */\nexport function vec3Cross( vecA: RawVector3, vecB: RawVector3 ): RawVector3 {\n  return [\n    vecA[ 1 ] * vecB[ 2 ] - vecA[ 2 ] * vecB[ 1 ],\n    vecA[ 2 ] * vecB[ 0 ] - vecA[ 0 ] * vecB[ 2 ],\n    vecA[ 0 ] * vecB[ 1 ] - vecA[ 1 ] * vecB[ 0 ],\n  ];\n}\n", "import { vec3Cross } from './vec3Cross';\nimport { vecDot } from '../vec/vecDot';\nimport { vecNeg } from '../vec/vecNeg';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Return a tangent which is orthogonal to normal.\n * If binormal is specified, it is also returned and it's orthogonal to both normal and tangent.\n */\nexport function vec3OrthoNormalize(\n  normal: RawVector3,\n  tangent: RawVector3 = [ 0.0, 1.0, 0.0 ],\n  binormal?: RawVector3,\n): {\n    normal: RawVector3,\n    tangent: RawVector3,\n    binormal: RawVector3,\n  } {\n  const n = vecNormalize( normal );\n  let t = vecNormalize( tangent );\n\n  let dotNT = vecDot( n, t );\n\n  if ( dotNT === 1.0 ) {\n    if ( Math.abs( n[ 1 ] ) > Math.abs( n[ 2 ] ) ) {\n      t = [ 0.0, 0.0, 1.0 ];\n    } else {\n      t = [ 0.0, 1.0, 0.0 ];\n    }\n    dotNT = vecDot( n, t );\n  }\n\n  t = vecNormalize( vecSub( t, vecScale( n, dotNT ) ) );\n\n  let b = vec3Cross( t, n );\n  if ( binormal && vecDot( b, binormal ) < 0.0 ) {\n    b = vecNeg( b );\n  }\n\n  return {\n    normal: n,\n    tangent: t,\n    binormal: b,\n  };\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Quaternion } from '../quat/Quaternion';\nimport { Vector } from '../vec/Vector';\nimport { vec3ApplyMatrix4 } from './vec3ApplyMatrix4';\nimport { vec3ApplyQuaternion } from './vec3ApplyQuaternion';\nimport { vec3Cross } from './vec3Cross';\nimport { vec3OrthoNormalize } from './vec3OrthoNormalize';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * A Vector3.\n */\nexport class Vector3 extends Vector<Vector3> {\n  public elements: RawVector3;\n\n  public constructor( v: RawVector3 = [ 0.0, 0.0, 0.0 ] ) {\n    super();\n    this.elements = v;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  public set x( x: number ) {\n    this.elements[ 0 ] = x;\n  }\n\n  /**\n   * An y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  public set y( y: number ) {\n    this.elements[ 1 ] = y;\n  }\n\n  /**\n   * An z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  public set z( z: number ) {\n    this.elements[ 2 ] = z;\n  }\n\n  public toString(): string {\n    return `Vector3( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) } )`;\n  }\n\n  /**\n   * Return a cross of this and another Vector3.\n   * @param vector Another vector\n   */\n  public cross( vector: Vector3 ): Vector3 {\n    return new Vector3( vec3Cross( this.elements, vector.elements ) );\n  }\n\n  /**\n   * Rotate this vector using a Quaternion.\n   * @param quaternion A quaternion\n   */\n  public applyQuaternion( quaternion: Quaternion ): Vector3 {\n    return new Vector3( vec3ApplyQuaternion( this.elements, quaternion.elements ) );\n  }\n\n  /**\n   * Multiply this vector (with an implicit 1 in the 4th dimension) by m.\n   */\n  public applyMatrix4( matrix: Matrix4 ): Vector3 {\n    return new Vector3( vec3ApplyMatrix4( this.elements, matrix.elements ) );\n  }\n\n  protected __new( v: RawVector3 ): Vector3 {\n    return new Vector3( v );\n  }\n\n  /**\n   * Vector3( 0.0, 0.0, 0.0 )\n   */\n  public static get zero(): Vector3 {\n    return new Vector3( [ 0.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 1.0, 0.0, 0.0 )\n   */\n  public static get px(): Vector3 {\n    return new Vector3( [ 1.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( -1.0, 0.0, 0.0 )\n   */\n  public static get nx(): Vector3 {\n    return new Vector3( [ -1.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, 1.0, 0.0 )\n   */\n  public static get py(): Vector3 {\n    return new Vector3( [ 0.0, 1.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, -1.0, 0.0 )\n   */\n  public static get ny(): Vector3 {\n    return new Vector3( [ 0.0, -1.0, 0.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, 0.0, 1.0 )\n   */\n  public static get pz(): Vector3 {\n    return new Vector3( [ 0.0, 0.0, 1.0 ] );\n  }\n\n  /**\n   * Vector3( 0.0, 0.0, -1.0 )\n   */\n  public static get nz(): Vector3 {\n    return new Vector3( [ 0.0, 0.0, -1.0 ] );\n  }\n\n  /**\n   * Vector3( 1.0, 1.0, 1.0 )\n   */\n  public static get one(): Vector3 {\n    return new Vector3( [ 1.0, 1.0, 1.0 ] );\n  }\n\n  /**\n   * Return a tangent which is orthogonal to normal.\n   * If binormal is specified, it is also returned and it's orthogonal to both normal and tangent.\n   */\n  public static orthoNormalize( normal: Vector3, tangent: Vector3, binormal: Vector3 ): {\n    normal: Vector3,\n    tangent: Vector3,\n    binormal: Vector3,\n  } {\n    const result = vec3OrthoNormalize( normal.elements, tangent.elements, binormal.elements );\n    return {\n      normal: new Vector3( result.normal ),\n      tangent: new Vector3( result.tangent ),\n      binormal: new Vector3( result.binormal ),\n    };\n  }\n}\n", "import type { RawBox3 } from './RawBox3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given point is contained in given box or not.\n * @param box A box\n * @param point A point\n */\nexport function box3ContainsPoint( box: RawBox3, point: RawVector3 ): boolean {\n  return (\n    box[ 0 ][ 0 ] <= point[ 0 ] &&\n    box[ 1 ][ 0 ] >= point[ 0 ] &&\n    box[ 0 ][ 1 ] <= point[ 1 ] &&\n    box[ 1 ][ 1 ] >= point[ 1 ] &&\n    box[ 0 ][ 2 ] <= point[ 2 ] &&\n    box[ 1 ][ 2 ] >= point[ 2 ]\n  );\n}\n", "import { Vector3 } from '../vec3/Vector3';\nimport { box3ContainsPoint } from './box3ContainsPoint';\nimport type { RawBox3 } from './RawBox3';\n\n/**\n * A 3D box.\n */\nexport class Box3 {\n  public min: Vector3;\n  public max: Vector3;\n\n  public constructor( min: Vector3 = Vector3.zero, max: Vector3 = Vector3.zero ) {\n    this.min = min;\n    this.max = max;\n  }\n\n  /**\n   * Itself but {@link RawBox3} form.\n   */\n  public get raw(): RawBox3 {\n    return [ this.min.elements, this.max.elements ];\n  }\n\n  /**\n   * Test if given point is contained in the box or not.\n   *\n   * @param point A point\n   */\n  public containsPoint( point: Vector3 ): boolean {\n    return box3ContainsPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Convert {@link RawBox3} to class form.\n   * @param box A {@link RawBox3}\n   */\n  public static fromRaw( box: RawBox3 ): Box3 {\n    return new Box3( new Vector3( box[ 0 ] ), new Vector3( box[ 1 ] ) );\n  }\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Who needs this?\n *\n * Intended to be used by {@link mat3CreateNormalMatrix}.\n */\nexport function mat3FromMat4Transpose(\n  source: RawMatrix4,\n): RawMatrix3 {\n  return [\n    source[ 0 ], source[ 4 ], source[ 8 ],\n    source[ 1 ], source[ 5 ], source[ 9 ],\n    source[ 2 ], source[ 6 ], source[ 10 ],\n  ];\n}\n", "import { vecScale } from '../vec/vecScale';\nimport type { RawMatrix3 } from './RawMatrix3';\n\n/**\n * Return an inverse of given mat3.\n *\n * Yoinked from Three.js\n */\nexport function mat3Inverse( m: RawMatrix3 ): RawMatrix3 {\n  const\n    n11 = m[ 0 ], n21 = m[ 1 ], n31 = m[ 2 ],\n    n12 = m[ 3 ], n22 = m[ 4 ], n32 = m[ 5 ],\n    n13 = m[ 6 ], n23 = m[ 7 ], n33 = m[ 8 ],\n    t11 = n33 * n22 - n32 * n23,\n    t12 = n32 * n13 - n33 * n12,\n    t13 = n23 * n12 - n22 * n13,\n    det = n11 * t11 + n21 * t12 + n31 * t13;\n\n  if ( det === 0.0 ) { return vecScale( m, 0.0 ); }\n\n  return vecScale( [\n    t11,\n    n31 * n23 - n33 * n21,\n    n32 * n21 - n31 * n22,\n    t12,\n    n33 * n11 - n31 * n13,\n    n31 * n12 - n32 * n11,\n    t13,\n    n21 * n13 - n23 * n11,\n    n22 * n11 - n21 * n12,\n  ], 1.0 / det );\n}\n", "import { mat3FromMat4Transpose } from './mat3FromMat4Transpose';\nimport { mat3Inverse } from './mat3Inverse';\nimport type { RawMatrix3 } from './RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Create a normal matrix out of a matrix4.\n *\n * @param matrix A matrix4\n */\nexport function mat3CreateNormalMatrix( m: RawMatrix4 ): RawMatrix3 {\n  return mat3Inverse( mat3FromMat4Transpose( m ) );\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\n\nexport function mat3Determinant( m: RawMatrix3 ): number {\n  const\n    n11 = m[ 0 ], n21 = m[ 1 ], n31 = m[ 2 ],\n    n12 = m[ 3 ], n22 = m[ 4 ], n32 = m[ 5 ],\n    n13 = m[ 6 ], n23 = m[ 7 ], n33 = m[ 8 ],\n    t11 = n33 * n22 - n32 * n23,\n    t12 = n32 * n13 - n33 * n12,\n    t13 = n23 * n12 - n22 * n13;\n\n  return n11 * t11 + n21 * t12 + n31 * t13;\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Create a matrix3 from matrix4.\n */\nexport function mat3FromMat4(\n  source: RawMatrix4,\n): RawMatrix3 {\n  return [\n    source[ 0 ], source[ 1 ], source[ 2 ],\n    source[ 4 ], source[ 5 ], source[ 6 ],\n    source[ 8 ], source[ 9 ], source[ 10 ],\n  ];\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\n\n/**\n * Convert a quaternion into a matrix3.\n *\n * Yoinked from Three.js.\n *\n * See: https://threejs.org/docs/#api/en/math/Matrix4.makeRotationFromQuaternion\n */\nexport function mat3FromQuaternion( quat: RawQuaternion ): RawMatrix3 {\n  const x = quat[ 0 ];\n  const y = quat[ 1 ];\n  const z = quat[ 2 ];\n  const w = quat[ 3 ];\n\n  return [\n    1.0 - 2.0 * y * y - 2.0 * z * z, 2.0 * x * y + 2.0 * z * w, 2.0 * x * z - 2.0 * y * w,\n    2.0 * x * y - 2.0 * z * w, 1.0 - 2.0 * x * x - 2.0 * z * z, 2.0 * y * z + 2.0 * x * w,\n    2.0 * x * z + 2.0 * y * w, 2.0 * y * z - 2.0 * x * w, 1.0 - 2.0 * x * x - 2.0 * y * y,\n  ];\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\n\n/**\n * Return a multiplication result of matrices.\n */\nexport function mat3Multiply( ...mats: RawMatrix3[] ): RawMatrix3 {\n  if ( mats.length < 2 ) {\n    return mats[ 0 ];\n  }\n\n  const a = mats.shift()!;\n  const b = mat3Multiply( ...mats );\n  const\n    a00 = a[ 0 ], a01 = a[ 1 ], a02 = a[ 2 ],\n    a10 = a[ 3 ], a11 = a[ 4 ], a12 = a[ 5 ],\n    a20 = a[ 6 ], a21 = a[ 7 ], a22 = a[ 8 ],\n    b00 = b[ 0 ], b01 = b[ 1 ], b02 = b[ 2 ],\n    b10 = b[ 3 ], b11 = b[ 4 ], b12 = b[ 5 ],\n    b20 = b[ 6 ], b21 = b[ 7 ], b22 = b[ 8 ];\n\n  return [\n    a00 * b00 + a10 * b01 + a20 * b02,\n    a01 * b00 + a11 * b01 + a21 * b02,\n    a02 * b00 + a12 * b01 + a22 * b02,\n\n    a00 * b10 + a10 * b11 + a20 * b12,\n    a01 * b10 + a11 * b11 + a21 * b12,\n    a02 * b10 + a12 * b11 + a22 * b12,\n\n    a00 * b20 + a10 * b21 + a20 * b22,\n    a01 * b20 + a11 * b21 + a21 * b22,\n    a02 * b20 + a12 * b21 + a22 * b22,\n  ];\n}\n", "import type { RawMatrix3 } from './RawMatrix3';\n\n/**\n * Transpose a mat3.\n */\nexport function mat3Transpose(\n  source: RawMatrix3,\n): RawMatrix3 {\n  return [\n    source[ 0 ], source[ 3 ], source[ 6 ],\n    source[ 1 ], source[ 4 ], source[ 7 ],\n    source[ 2 ], source[ 5 ], source[ 8 ],\n  ];\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Quaternion } from '../quat/Quaternion';\nimport { mat3CreateNormalMatrix } from './mat3CreateNormalMatrix';\nimport { mat3Determinant } from './mat3Determinant';\nimport { mat3FromMat4 } from './mat3FromMat4';\nimport { mat3FromQuaternion } from './mat3FromQuaternion';\nimport { mat3Inverse } from './mat3Inverse';\nimport { mat3Multiply } from './mat3Multiply';\nimport { mat3Transpose } from './mat3Transpose';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix3 } from './RawMatrix3';\n\nconst rawIdentityMatrix3: RawMatrix3 = [\n  1.0, 0.0, 0.0,\n  0.0, 1.0, 0.0,\n  0.0, 0.0, 1.0,\n];\n\n/**\n * A Matrix3.\n */\nexport class Matrix3 {\n  public elements: RawMatrix3;\n\n  public constructor( v: RawMatrix3 = rawIdentityMatrix3 ) {\n    this.elements = v;\n  }\n\n  /**\n   * Itself but transposed.\n   */\n  public get transpose(): Matrix3 {\n    return new Matrix3( mat3Transpose( this.elements ) );\n  }\n\n  /**\n   * Its determinant.\n   */\n  public get determinant(): number {\n    return mat3Determinant( this.elements );\n  }\n\n  /**\n   * Itself but inverted.\n   */\n  public get inverse(): Matrix3 {\n    return new Matrix3( mat3Inverse( this.elements ) );\n  }\n\n  /**\n   * Itself but matrix4.\n   */\n  public get matrix4(): Matrix4 {\n    return Matrix4.fromMatrix3( this );\n  }\n\n  public toString(): string {\n    const m = this.elements.map( ( v ) => v.toFixed( 3 ) );\n    return `Matrix3( ${ m[ 0 ] }, ${ m[ 3 ] }, ${ m[ 6 ] }; ${ m[ 1 ] }, ${ m[ 4 ] }, ${ m[ 7 ] }; ${ m[ 2 ] }, ${ m[ 5 ] }, ${ m[ 8 ] } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Matrix3 {\n    return new Matrix3( this.elements.concat() as RawMatrix3 );\n  }\n\n  /**\n   * Multiply this Matrix3 by one or more Matrix3s.\n   */\n  public multiply( ...matrices: Matrix3[] ): Matrix3 {\n    return Matrix3.multiply( this, ...matrices );\n  }\n\n  /**\n   * Multiply this Matrix3 by a scalar.\n   */\n  public scaleScalar( scalar: number ): Matrix3 {\n    return new Matrix3( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * An identity Matrix4.\n   */\n  public static get identity(): Matrix3 {\n    return new Matrix3( rawIdentityMatrix3 );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param matrices Matrices\n   */\n  public static multiply( ...matrices: Matrix3[] ): Matrix3 {\n    if ( matrices.length === 0 ) {\n      return Matrix3.identity;\n    } else {\n      return new Matrix3( mat3Multiply( ...matrices.map( ( m ) => m.elements ) ) );\n    }\n  }\n\n  /**\n   * Create a normal matrix out of matrix4.\n   * @param matrix4 A matrix4\n   */\n  public static createNormalMatrix( matrix4: Matrix4 ): Matrix3 {\n    return new Matrix3( mat3CreateNormalMatrix( matrix4.elements ) );\n  }\n\n  /**\n   * Cast a {@link Matrix4} into a Matrix3.\n   * @param matrix4 A matrix4\n   */\n  public static fromMatrix4( matrix4: Matrix4 ): Matrix3 {\n    return new Matrix3( mat3FromMat4( matrix4.elements ) );\n  }\n\n  /**\n   * Create a matrix out of a {@link Quaternion}.\n   * @param quaternion A quaternion\n   */\n  public static fromQuaternion( quaternion: Quaternion ): Matrix3 {\n    return new Matrix3( mat3FromQuaternion( quaternion.elements ) );\n  }\n}\n", "import type { RawMatrix4 } from '.';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\n\n/**\n * Convert a quaternion into a matrix4.\n *\n * Yoinked from Three.js.\n *\n * See: https://threejs.org/docs/#api/en/math/Matrix4.makeRotationFromQuaternion\n */\nexport function mat4FromQuaternion( quat: RawQuaternion ): RawMatrix4 {\n  const x = quat[ 0 ];\n  const y = quat[ 1 ];\n  const z = quat[ 2 ];\n  const w = quat[ 3 ];\n\n  return [\n    1.0 - 2.0 * y * y - 2.0 * z * z, 2.0 * x * y + 2.0 * z * w, 2.0 * x * z - 2.0 * y * w, 0.0,\n    2.0 * x * y - 2.0 * z * w, 1.0 - 2.0 * x * x - 2.0 * z * z, 2.0 * y * z + 2.0 * x * w, 0.0,\n    2.0 * x * z + 2.0 * y * w, 2.0 * y * z - 2.0 * x * w, 1.0 - 2.0 * x * x - 2.0 * y * y, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n  ];\n}\n", "import { mat4FromQuaternion } from './mat4FromQuaternion';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Compose a matrix out of position, scale, and rotation.\n * Yoinked from Three.js.\n */\nexport function mat4Compose(\n  position: RawVector3,\n  rotation: RawQuaternion,\n  scale: RawVector3,\n): RawMatrix4 {\n  const matRot = mat4FromQuaternion( rotation );\n\n  const sx = scale[ 0 ], sy = scale[ 1 ], sz = scale[ 2 ];\n\n  return [\n    matRot[ 0 ] * sx,\n    matRot[ 1 ] * sx,\n    matRot[ 2 ] * sx,\n    0.0,\n\n    matRot[ 4 ] * sy,\n    matRot[ 5 ] * sy,\n    matRot[ 6 ] * sy,\n    0.0,\n\n    matRot[ 8 ] * sz,\n    matRot[ 9 ] * sz,\n    matRot[ 10 ] * sz,\n    0.0,\n\n    position[ 0 ],\n    position[ 1 ],\n    position[ 2 ],\n    1.0\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Return a determinant of given mat4.\n */\nexport function mat4Determinant( m: RawMatrix4 ): number {\n  const\n    a00 = m[  0 ], a01 = m[  1 ], a02 = m[  2 ], a03 = m[  3 ],\n    a10 = m[  4 ], a11 = m[  5 ], a12 = m[  6 ], a13 = m[  7 ],\n    a20 = m[  8 ], a21 = m[  9 ], a22 = m[ 10 ], a23 = m[ 11 ],\n    a30 = m[ 12 ], a31 = m[ 13 ], a32 = m[ 14 ], a33 = m[ 15 ],\n    b00 = a00 * a11 - a01 * a10,  b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,  b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,  b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,  b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,  b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,  b11 = a22 * a33 - a23 * a32;\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n", "import type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a Quaternion out of a rotation matrix.\n * Yoinked from Three.js.\n */\nexport function quatFromMatrix3( m: RawMatrix3 ): RawQuaternion {\n  const m11 = m[ 0 ], m12 = m[ 3 ], m13 = m[ 6 ],\n    m21 = m[ 1 ], m22 = m[ 4 ], m23 = m[ 7 ],\n    m31 = m[ 2 ], m32 = m[ 5 ], m33 = m[ 8 ],\n    trace = m11 + m22 + m33;\n\n  if ( trace > 0 ) {\n    const s = 0.5 / Math.sqrt( trace + 1.0 );\n    return [\n      ( m32 - m23 ) * s,\n      ( m13 - m31 ) * s,\n      ( m21 - m12 ) * s,\n      0.25 / s\n    ];\n  } else if ( m11 > m22 && m11 > m33 ) {\n    const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n    return [\n      0.25 * s,\n      ( m12 + m21 ) / s,\n      ( m13 + m31 ) / s,\n      ( m32 - m23 ) / s\n    ];\n  } else if ( m22 > m33 ) {\n    const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n    return [\n      ( m12 + m21 ) / s,\n      0.25 * s,\n      ( m23 + m32 ) / s,\n      ( m13 - m31 ) / s\n    ];\n  } else {\n    const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n    return [\n      ( m13 + m31 ) / s,\n      ( m23 + m32 ) / s,\n      0.25 * s,\n      ( m21 - m12 ) / s\n    ];\n  }\n}\n", "import { mat3FromMat4 } from '../mat3/mat3FromMat4';\nimport { quatFromMatrix3 } from './quatFromMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a Quaternion out of a rotation matrix.\n */\nexport function quatFromMatrix4( m: RawMatrix4 ): RawQuaternion {\n  return quatFromMatrix3( mat3FromMat4( m ) );\n}\n", "import { mat4Determinant } from './mat4Determinant';\nimport { quatFromMatrix4 } from '../quat/quatFromMatrix4';\nimport { vecLength } from '../vec/vecLength';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Decompose a matrix into a position, a scale, and a rotation.\n * Yoinked from Three.js.\n */\nexport function mat4Decompose( m: RawMatrix4 ): {\n  position: RawVector3;\n  scale: RawVector3;\n  rotation: RawQuaternion;\n} {\n  let sx = vecLength( [ m[ 0 ], m[ 1 ], m[ 2 ] ] );\n  const sy = vecLength( [ m[ 4 ], m[ 5 ], m[ 6 ] ] );\n  const sz = vecLength( [ m[ 8 ], m[ 9 ], m[ 10 ] ] );\n\n  // if determinant is negative, we need to invert one scale\n  const det = mat4Determinant( m );\n  if ( det < 0 ) { sx = -sx; }\n\n  const invSx = 1.0 / sx;\n  const invSy = 1.0 / sy;\n  const invSz = 1.0 / sz;\n\n  const rotationMatrix = m.concat() as RawMatrix4;\n\n  rotationMatrix[ 0 ] *= invSx;\n  rotationMatrix[ 1 ] *= invSx;\n  rotationMatrix[ 2 ] *= invSx;\n\n  rotationMatrix[ 4 ] *= invSy;\n  rotationMatrix[ 5 ] *= invSy;\n  rotationMatrix[ 6 ] *= invSy;\n\n  rotationMatrix[ 8 ] *= invSz;\n  rotationMatrix[ 9 ] *= invSz;\n  rotationMatrix[ 10 ] *= invSz;\n\n  return {\n    position: [ m[ 12 ], m[ 13 ], m[ 14 ] ],\n    scale: [ sx, sy, sz ],\n    rotation: quatFromMatrix4( rotationMatrix ),\n  };\n}\n", "import type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Create a matrix4 from matrix3.\n */\nexport function mat4FromMat3(\n  source: RawMatrix3,\n): RawMatrix4 {\n  return [\n    source[ 0 ], source[ 1 ], source[ 2 ], 0.0,\n    source[ 3 ], source[ 4 ], source[ 5 ], 0.0,\n    source[ 6 ], source[ 7 ], source[ 8 ], 0.0,\n    0.0, 0.0, 0.0, 1.0,\n  ];\n}\n", "import { vecScale } from '../vec/vecScale';\nimport type { RawMatrix4 } from './RawMatrix4';\n\n/**\n *  an inverse of given mat4.\n */\nexport function mat4Inverse( m: RawMatrix4 ): RawMatrix4 {\n  const\n    a00 = m[  0 ], a01 = m[  1 ], a02 = m[  2 ], a03 = m[  3 ],\n    a10 = m[  4 ], a11 = m[  5 ], a12 = m[  6 ], a13 = m[  7 ],\n    a20 = m[  8 ], a21 = m[  9 ], a22 = m[ 10 ], a23 = m[ 11 ],\n    a30 = m[ 12 ], a31 = m[ 13 ], a32 = m[ 14 ], a33 = m[ 15 ],\n    b00 = a00 * a11 - a01 * a10,  b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,  b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,  b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,  b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,  b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,  b11 = a22 * a33 - a23 * a32;\n\n  const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if ( det === 0.0 ) { return vecScale( m, 0.0 ); }\n\n  return vecScale( [\n    a11 * b11 - a12 * b10 + a13 * b09,\n    a02 * b10 - a01 * b11 - a03 * b09,\n    a31 * b05 - a32 * b04 + a33 * b03,\n    a22 * b04 - a21 * b05 - a23 * b03,\n    a12 * b08 - a10 * b11 - a13 * b07,\n    a00 * b11 - a02 * b08 + a03 * b07,\n    a32 * b02 - a30 * b05 - a33 * b01,\n    a20 * b05 - a22 * b02 + a23 * b01,\n    a10 * b10 - a11 * b08 + a13 * b06,\n    a01 * b08 - a00 * b10 - a03 * b06,\n    a30 * b04 - a31 * b02 + a33 * b00,\n    a21 * b02 - a20 * b04 - a23 * b00,\n    a11 * b07 - a10 * b09 - a12 * b06,\n    a00 * b09 - a01 * b07 + a02 * b06,\n    a31 * b01 - a30 * b03 - a32 * b00,\n    a20 * b03 - a21 * b01 + a22 * b00,\n  ], 1.0 / det );\n}\n", "import { vec3Cross } from '../vec3/vec3Cross';\nimport { vecAdd } from '../vec/vecAdd';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a \"LookAt\" matrix.\n *\n * See also: {@link mat4LookAtInverse}\n */\nexport function mat4LookAt(\n  position: RawVector3,\n  target: RawVector3 = [ 0.0, 0.0, 0.0 ],\n  up: RawVector3 = [ 0.0, 1.0, 0.0 ],\n  roll = 0.0,\n): RawMatrix4 {\n  const dir = vecNormalize( vecSub( position, target ) );\n\n  let sid = vecNormalize( vec3Cross( up, dir ) );\n\n  if ( roll !== 0.0 ) {\n    sid = vecAdd(\n      vecScale( sid, Math.cos( roll ) ),\n      vecScale( vec3Cross( dir, sid ), Math.sin( roll ) ),\n    );\n  }\n\n  const top = vec3Cross( dir, sid );\n\n  return [\n    sid[ 0 ], sid[ 1 ], sid[ 2 ], 0.0,\n    top[ 0 ], top[ 1 ], top[ 2 ], 0.0,\n    dir[ 0 ], dir[ 1 ], dir[ 2 ], 0.0,\n    position[ 0 ], position[ 1 ], position[ 2 ], 1.0\n  ];\n}\n", "import { vec3Cross } from '../vec3/vec3Cross';\nimport { vecAdd } from '../vec/vecAdd';\nimport { vecDot } from '../vec/vecDot';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate an inverse of \"LookAt\" matrix. Good for creating a view matrix.\n *\n * See also: {@link mat4LookAt}\n */\nexport function mat4LookAtInverse(\n  position: RawVector3,\n  target: RawVector3 = [ 0.0, 0.0, 0.0 ],\n  up: RawVector3 = [ 0.0, 1.0, 0.0 ],\n  roll = 0.0,\n): RawMatrix4 {\n  const dir = vecNormalize( vecSub( position, target ) );\n\n  let sid = vecNormalize( vec3Cross( up, dir ) );\n\n  if ( roll !== 0.0 ) {\n    sid = vecAdd(\n      vecScale( sid, Math.cos( roll ) ),\n      vecScale( vec3Cross( dir, sid ), Math.sin( roll ) ),\n    );\n  }\n\n  const top = vec3Cross( dir, sid );\n\n  return [\n    sid[ 0 ], top[ 0 ], dir[ 0 ], 0.0,\n    sid[ 1 ], top[ 1 ], dir[ 1 ], 0.0,\n    sid[ 2 ], top[ 2 ], dir[ 2 ], 0.0,\n    -vecDot( sid, position ),\n    -vecDot( top, position ),\n    -vecDot( dir, position ),\n    1.0,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Return a multiplication result of matrices.\n */\nexport function mat4Multiply( ...mats: RawMatrix4[] ): RawMatrix4 {\n  if ( mats.length < 2 ) {\n    return mats[ 0 ];\n  }\n\n  const a = mats.shift()!;\n  const b = mat4Multiply( ...mats );\n  const\n    a00 = a[  0 ], a01 = a[  1 ], a02 = a[  2 ], a03 = a[  3 ],\n    a10 = a[  4 ], a11 = a[  5 ], a12 = a[  6 ], a13 = a[  7 ],\n    a20 = a[  8 ], a21 = a[  9 ], a22 = a[ 10 ], a23 = a[ 11 ],\n    a30 = a[ 12 ], a31 = a[ 13 ], a32 = a[ 14 ], a33 = a[ 15 ],\n    b00 = b[  0 ], b01 = b[  1 ], b02 = b[  2 ], b03 = b[  3 ],\n    b10 = b[  4 ], b11 = b[  5 ], b12 = b[  6 ], b13 = b[  7 ],\n    b20 = b[  8 ], b21 = b[  9 ], b22 = b[ 10 ], b23 = b[ 11 ],\n    b30 = b[ 12 ], b31 = b[ 13 ], b32 = b[ 14 ], b33 = b[ 15 ];\n\n  return [\n    a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03,\n    a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03,\n    a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03,\n    a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03,\n\n    a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13,\n    a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13,\n    a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13,\n    a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13,\n\n    a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23,\n    a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23,\n    a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23,\n    a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23,\n\n    a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33,\n    a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33,\n    a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33,\n    a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a \"Perspective\" projection matrix.\n *\n * @param fov Field of View Y, **IN DEGREES**\n * @param near Near clip plane\n * @param far Far clip plane\n * @param aspect Aspect ratio. **`1.0` BY DEFAULT**\n */\nexport function mat4Perspective(\n  fov = 45.0,\n  near = 0.01,\n  far = 100.0,\n  aspect = 1.0,\n): RawMatrix4 {\n  const p = 1.0 / Math.tan( fov * Math.PI / 360.0 );\n  const d = ( far - near );\n  return [\n    p / aspect, 0.0, 0.0, 0.0,\n    0.0, p, 0.0, 0.0,\n    0.0, 0.0, -( far + near ) / d, -1.0,\n    0.0, 0.0, -2 * far * near / d, 0.0\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d rotation matrix, rotates around x axis.\n */\nexport function mat4RotationX( theta: number ): RawMatrix4 {\n  const c = Math.cos( theta );\n  const s = Math.sin( theta );\n\n  return [\n    1, 0, 0, 0,\n    0, c, -s, 0,\n    0, s, c, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d rotation matrix, rotates around y axis.\n */\nexport function mat4RotationY( theta: number ): RawMatrix4 {\n  const c = Math.cos( theta );\n  const s = Math.sin( theta );\n\n  return [\n    c, 0, s, 0,\n    0, 1, 0, 0,\n    -s, 0, c, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d rotation matrix, rotates around z axis.\n */\nexport function mat4RotationZ( theta: number ): RawMatrix4 {\n  const c = Math.cos( theta );\n  const s = Math.sin( theta );\n\n  return [\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a 3d scaling matrix.\n */\nexport function mat4Scale( vec: RawVector3 ): RawMatrix4 {\n  return [\n    vec[ 0 ], 0, 0, 0,\n    0, vec[ 1 ], 0, 0,\n    0, 0, vec[ 2 ], 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Generate a 3d scaling matrix by a scalar.\n */\nexport function mat4ScaleScalar( scalar: number ): RawMatrix4 {\n  return [\n    scalar, 0, 0, 0,\n    0, scalar, 0, 0,\n    0, 0, scalar, 0,\n    0, 0, 0, 1,\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a translation matrix.\n */\nexport function mat4Translate( vec: RawVector3 ): RawMatrix4 {\n  return [\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    vec[ 0 ], vec[ 1 ], vec[ 2 ], 1\n  ];\n}\n", "import type { RawMatrix4 } from './RawMatrix4';\n\n/**\n * Transpose a mat4.\n */\nexport function mat4Transpose( m: RawMatrix4 ): RawMatrix4 {\n  return [\n    m[ 0 ], m[ 4 ], m[ 8 ], m[ 12 ],\n    m[ 1 ], m[ 5 ], m[ 9 ], m[ 13 ],\n    m[ 2 ], m[ 6 ], m[ 10 ], m[ 14 ],\n    m[ 3 ], m[ 7 ], m[ 11 ], m[ 15 ],\n  ];\n}\n", "import { Matrix3 } from '../mat3/Matrix3';\nimport { Quaternion } from '../quat/Quaternion';\nimport { Vector3 } from '../vec3/Vector3';\nimport { mat4Compose } from './mat4Compose';\nimport { mat4Decompose } from './mat4Decompose';\nimport { mat4Determinant } from './mat4Determinant';\nimport { mat4FromMat3 } from './mat4FromMat3';\nimport { mat4FromQuaternion } from './mat4FromQuaternion';\nimport { mat4Inverse } from './mat4Inverse';\nimport { mat4LookAt } from './mat4LookAt';\nimport { mat4LookAtInverse } from './mat4LookAtInverse';\nimport { mat4Multiply } from './mat4Multiply';\nimport { mat4Perspective } from './mat4Perspective';\nimport { mat4RotationX } from './mat4RotationX';\nimport { mat4RotationY } from './mat4RotationY';\nimport { mat4RotationZ } from './mat4RotationZ';\nimport { mat4Scale } from './mat4Scale';\nimport { mat4ScaleScalar } from './mat4ScaleScalar';\nimport { mat4Translate } from './mat4Translate';\nimport { mat4Transpose } from './mat4Transpose';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix4 } from './RawMatrix4';\n\nconst rawIdentityMatrix4: RawMatrix4 = [\n  1.0, 0.0, 0.0, 0.0,\n  0.0, 1.0, 0.0, 0.0,\n  0.0, 0.0, 1.0, 0.0,\n  0.0, 0.0, 0.0, 1.0\n];\n\n/**\n * A Matrix4.\n */\nexport class Matrix4 {\n  public elements: RawMatrix4;\n\n  public constructor( v: RawMatrix4 = rawIdentityMatrix4 ) {\n    this.elements = v;\n  }\n\n  /**\n   * Itself but transposed.\n   */\n  public get transpose(): Matrix4 {\n    return new Matrix4( mat4Transpose( this.elements ) );\n  }\n\n  /**\n   * Its determinant.\n   */\n  public get determinant(): number {\n    return mat4Determinant( this.elements );\n  }\n\n  /**\n   * Itself but inverted.\n   */\n  public get inverse(): Matrix4 {\n    return new Matrix4( mat4Inverse( this.elements ) );\n  }\n\n  /**\n   * Itself but matrix3.\n   */\n  public get matrix3(): Matrix3 {\n    return Matrix3.fromMatrix4( this );\n  }\n\n  /**\n   * Itself but normal matrix.\n   */\n  public get normalMatrix(): Matrix3 {\n    return Matrix3.createNormalMatrix( this );\n  }\n\n  public toString(): string {\n    const m = this.elements.map( ( v ) => v.toFixed( 3 ) );\n    return `Matrix4( ${ m[ 0 ] }, ${ m[ 4 ] }, ${ m[ 8 ] }, ${ m[ 12 ] }; ${ m[ 1 ] }, ${ m[ 5 ] }, ${ m[ 9 ] }, ${ m[ 13 ] }; ${ m[ 2 ] }, ${ m[ 6 ] }, ${ m[ 10 ] }, ${ m[ 14 ] }; ${ m[ 3 ] }, ${ m[ 7 ] }, ${ m[ 11 ] }, ${ m[ 15 ] } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Matrix4 {\n    return new Matrix4( this.elements.concat() as RawMatrix4 );\n  }\n\n  /**\n   * Multiply this Matrix4 by one or more Matrix4s.\n   */\n  public multiply( ...matrices: Matrix4[] ): Matrix4 {\n    return Matrix4.multiply( this, ...matrices );\n  }\n\n  /**\n   * Multiply this Matrix4 by a scalar.\n   */\n  public scaleScalar( scalar: number ): Matrix4 {\n    return new Matrix4( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * Decompose this matrix into a position, a scale, and a rotation.\n   */\n  public decompose(): { position: Vector3; scale: Vector3; rotation: Quaternion } {\n    const { position, scale, rotation } = mat4Decompose( this.elements );\n\n    return {\n      position: new Vector3( position ),\n      scale: new Vector3( scale ),\n      rotation: new Quaternion( rotation ),\n    };\n  }\n\n  /**\n   * An identity Matrix4.\n   */\n  public static get identity(): Matrix4 {\n    return new Matrix4( rawIdentityMatrix4 );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param matrices Matrices\n   */\n  public static multiply( ...matrices: Matrix4[] ): Matrix4 {\n    if ( matrices.length === 0 ) {\n      return Matrix4.identity;\n    } else {\n      return new Matrix4( mat4Multiply( ...matrices.map( ( m ) => m.elements ) ) );\n    }\n  }\n\n  /**\n   * Create a matrix out of a {@link Quaternion}.\n   * @param quaternion A quaternion\n   */\n  public static fromQuaternion( quaternion: Quaternion ): Matrix4 {\n    return new Matrix4( mat4FromQuaternion( quaternion.elements ) );\n  }\n\n  /**\n   * Cast a {@link Matrix3} into a Matrix4.\n   * @param matrix3 A matrix3\n   */\n  public static fromMatrix3( matrix3: Matrix3 ): Matrix4 {\n    return new Matrix4( mat4FromMat3( matrix3.elements ) );\n  }\n\n  /**\n   * Generate a translation matrix.\n   * @param vector Translation\n   */\n  public static translate( vector: Vector3 ): Matrix4 {\n    return new Matrix4( mat4Translate( vector.elements ) );\n  }\n\n  /**\n   * Generate a 3d scaling matrix.\n   * @param vector Scale\n   */\n  public static scale( vector: Vector3 ): Matrix4 {\n    return new Matrix4( mat4Scale( vector.elements ) );\n  }\n\n  /**\n   * Generate a 3d scaling matrix by a scalar.\n   * @param vector Scale\n   */\n  public static scaleScalar( scalar: number ): Matrix4 {\n    return new Matrix4( mat4ScaleScalar( scalar ) );\n  }\n\n  /**\n   * Generate a 3d rotation matrix, rotates around x axis.\n   * @param vector Scale\n   */\n  public static rotationX( theta: number ): Matrix4 {\n    return new Matrix4( mat4RotationX( theta ) );\n  }\n\n  /**\n   * Generate a 3d rotation matrix, rotates around y axis.\n   * @param vector Scale\n   */\n  public static rotationY( theta: number ): Matrix4 {\n    return new Matrix4( mat4RotationY( theta ) );\n  }\n\n  /**\n   * Generate a 3d rotation matrix, rotates around z axis.\n   * @param vector Scale\n   */\n  public static rotationZ( theta: number ): Matrix4 {\n    return new Matrix4( mat4RotationZ( theta ) );\n  }\n\n  /**\n   * Generate a \"LookAt\" matrix.\n   *\n   * See also: {@link lookAtInverse}\n   */\n  public static lookAt(\n    position: Vector3,\n    target = new Vector3( [ 0.0, 0.0, 0.0 ] ),\n    up = new Vector3( [ 0.0, 1.0, 0.0 ] ),\n    roll = 0.0\n  ): Matrix4 {\n    return new Matrix4( mat4LookAt(\n      position.elements,\n      target.elements,\n      up.elements,\n      roll,\n    ) );\n  }\n\n  /**\n   * Generate an inverse of \"LookAt\" matrix. Good for creating a view matrix.\n   *\n   * See also: {@link lookAt}\n   */\n  public static lookAtInverse(\n    position: Vector3,\n    target = new Vector3( [ 0.0, 0.0, 0.0 ] ),\n    up = new Vector3( [ 0.0, 1.0, 0.0 ] ),\n    roll = 0.0\n  ): Matrix4 {\n    return new Matrix4( mat4LookAtInverse(\n      position.elements,\n      target.elements,\n      up.elements,\n      roll,\n    ) );\n  }\n\n  /**\n   * Generate a \"Perspective\" projection matrix.\n   * It won't include aspect!\n   */\n  public static perspective( fov = 45.0, near = 0.01, far = 100.0 ): Matrix4 {\n    return new Matrix4( mat4Perspective( fov, near, far ) );\n  }\n\n  /**\n   * Compose a matrix out of position, scale, and rotation.\n   * Yoinked from Three.js.\n   */\n  public static compose( position: Vector3, rotation: Quaternion, scale: Vector3 ): Matrix4 {\n    return new Matrix4( mat4Compose( position.elements, rotation.elements, scale.elements ) );\n  }\n}\n", "import type { RawQuaternion } from './RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a Quaternion out of axis and angle.\n */\nexport function quatFromAxisAngle( axis: RawVector3, angle: number ): RawQuaternion {\n  const halfAngle = angle / 2.0;\n  const sinHalfAngle = Math.sin( halfAngle );\n  return [\n    axis[ 0 ] * sinHalfAngle,\n    axis[ 1 ] * sinHalfAngle,\n    axis[ 2 ] * sinHalfAngle,\n    Math.cos( halfAngle )\n  ];\n}\n", "import { vec3OrthoNormalize } from '../vec3/vec3OrthoNormalize';\nimport type { RawQuaternion } from './RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a quaternion which looks at the direction of `look`.\n */\nexport function quatLookRotation( look: RawVector3, up?: RawVector3 ): RawQuaternion {\n  const { normal, tangent, binormal } = vec3OrthoNormalize( look, up ?? [ 0.0, 1.0, 0.0 ] );\n\n  const w = Math.sqrt( 1.0 + binormal[ 0 ] + tangent[ 1 ] + normal[ 2 ] ) * 0.5;\n  const invW4 = 0.25 / w;\n\n  return [\n    ( tangent[ 2 ] - normal[ 1 ] ) * invW4,\n    ( normal[ 0 ] - binormal[ 2 ] ) * invW4,\n    ( binormal[ 1 ] - tangent[ 0 ] ) * invW4,\n    w,\n  ];\n}\n", "import { vecLength } from '../vec/vecLength';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Normalize given quaternion.\n *\n * It's almost identical as {@link vecNormalize},\n * but it will return an identity quaternion instead\n * when it recieves a quaternion which length is zero.\n */\nexport function quatNormalize( vec: RawQuaternion ): RawQuaternion {\n  const len = vecLength( vec );\n  if ( len === 0.0 ) {\n    return [ 0.0, 0.0, 0.0, 1.0 ];\n  }\n  return vecScale( vec, 1.0 / len );\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a quaternion rotates around x axis.\n * @param theta An angle around x axis, in degree\n */\nexport function quatRotationX( theta: number ): RawQuaternion {\n  return [ Math.sin( theta / 2.0 ), 0.0, 0.0, Math.cos( theta / 2.0 ) ];\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a quaternion rotates around y axis.\n * @param theta An angle around y axis, in degree\n */\nexport function quatRotationY( theta: number ): RawQuaternion {\n  return [ 0.0, Math.sin( theta / 2.0 ), 0.0, Math.cos( theta / 2.0 ) ];\n}\n", "import type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Generate a quaternion rotates around z axis.\n * @param theta An angle around z axis, in degree\n */\nexport function quatRotationZ( theta: number ): RawQuaternion {\n  return [ 0.0, 0.0, Math.sin( theta / 2.0 ), Math.cos( theta / 2.0 ) ];\n}\n", "import { vecDot, vecNeg, vecNormalize } from '..';\nimport type { RawQuaternion } from './RawQuaternion';\n\n/**\n * Interpolate between two quaternions.\n * @param a \"from\" quaternion\n * @param b \"to\" quaternion\n * @param t How much do we want to rotate the a to b\n */\nexport function quatSlerp( a: RawQuaternion, b: RawQuaternion, t: number ): RawQuaternion {\n  if ( t === 0.0 ) { return a.concat() as RawQuaternion; }\n  if ( t === 1.0 ) { return b.concat() as RawQuaternion; }\n\n  // Ref: https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n  // Ref: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n  let cosHalfTheta = vecDot( a, b );\n\n  if ( cosHalfTheta < 0.0 ) {\n    b = vecNeg( b );\n    cosHalfTheta = -cosHalfTheta;\n  }\n\n  // I think you two are same\n  if ( cosHalfTheta >= 1.0 ) {\n    return a.concat() as RawQuaternion;\n  }\n\n  const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n  // fallback to simple lerp\n  if ( sqrSinHalfTheta <= Number.EPSILON ) {\n    const s = 1.0 - t;\n\n    return vecNormalize( [\n      s * a[ 0 ] + t * b[ 0 ],\n      s * a[ 1 ] + t * b[ 1 ],\n      s * a[ 2 ] + t * b[ 2 ],\n      s * a[ 3 ] + t * b[ 3 ],\n    ] );\n  }\n\n  // welcome\n  const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n  const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n  const ratioA = Math.sin( ( 1.0 - t ) * halfTheta ) / sinHalfTheta;\n  const ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n  return [\n    a[ 0 ] * ratioA + b[ 0 ] * ratioB,\n    a[ 1 ] * ratioA + b[ 1 ] * ratioB,\n    a[ 2 ] * ratioA + b[ 2 ] * ratioB,\n    a[ 3 ] * ratioA + b[ 3 ] * ratioB,\n  ];\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Vector3 } from '../vec3/Vector3';\nimport { mat4FromQuaternion } from '../mat4/mat4FromQuaternion';\nimport { quatFromAxisAngle } from './quatFromAxisAngle';\nimport { quatFromMatrix4 } from './quatFromMatrix4';\nimport { quatInverse } from './quatInverse';\nimport { quatLookRotation } from './quatLookRotation';\nimport { quatMultiply } from './quatMultiply';\nimport { quatNormalize } from './quatNormalize';\nimport { quatRotationX } from './quatRotationX';\nimport { quatRotationY } from './quatRotationY';\nimport { quatRotationZ } from './quatRotationZ';\nimport { quatSlerp } from './quatSlerp';\nimport { vecLength } from '../vec/vecLength';\nimport { vecLengthSq } from '../vec/vecLengthSq';\nimport type { RawQuaternion } from './RawQuaternion';\n\nconst rawIdentityQuaternion: RawQuaternion = [ 0.0, 0.0, 0.0, 1.0 ];\n\n/**\n * A Quaternion.\n */\nexport class Quaternion {\n  public elements: RawQuaternion; // [ x, y, z; w ]\n\n  public constructor( elements: RawQuaternion = rawIdentityQuaternion ) {\n    this.elements = elements;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  /**\n   * An y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  /**\n   * An z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  /**\n   * An w component of this.\n   */\n  public get w(): number {\n    return this.elements[ 3 ];\n  }\n\n  public toString(): string {\n    return `Quaternion( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) }, ${ this.w.toFixed( 3 ) } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Quaternion {\n    return new Quaternion( this.elements.concat() as RawQuaternion );\n  }\n\n  /**\n   * Itself but converted into a Matrix4.\n   */\n  public get matrix4(): Matrix4 {\n    return new Matrix4( mat4FromQuaternion( this.elements ) );\n  }\n\n  /**\n   * An inverse of this.\n   */\n  public get inversed(): Quaternion {\n    return new Quaternion( quatInverse( this.elements ) );\n  }\n\n  /**\n   * The length of this.\n   */\n  public get length(): number {\n    return vecLength( this.elements );\n  }\n\n  /**\n   * The squared length of this.\n   */\n  public get lengthSq(): number {\n    return vecLengthSq( this.elements );\n  }\n\n  /**\n   * A normalized this.\n   */\n  public get normalized(): Quaternion {\n    return new Quaternion( quatNormalize( this.elements ) );\n  }\n\n  /**\n   * Multiply one or more Quaternions with this.\n   * @param quaternions Other Quaternions\n   */\n  public multiply( ...quaternions: Quaternion[] ): Quaternion {\n    return Quaternion.multiply( this, ...quaternions );\n  }\n\n  /**\n   * Interpolate between this and given quaternion.\n   * @param b Another Quaternion\n   * @param t How much do we want to rotate this to b\n   */\n  public slerp( b: Quaternion, t: number ): Quaternion {\n    return Quaternion.slerp( this, b, t );\n  }\n\n  /**\n   * An identity Quaternion.\n   */\n  public static get identity(): Quaternion {\n    return new Quaternion( rawIdentityQuaternion );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param quaternion Quaternions\n   */\n  public static multiply( ...quaternions: Quaternion[] ): Quaternion {\n    if ( quaternions.length === 0 ) {\n      return Quaternion.identity;\n    } else {\n      return new Quaternion( quatMultiply( ...quaternions.map( ( q ) => q.elements ) ) );\n    }\n  }\n\n  /**\n   * Interpolate between two quaternions.\n   * @param a \"from\" quaternion\n   * @param b \"to\" quaternion\n   * @param t How much do we want to rotate the a to b\n   */\n  public static slerp( a: Quaternion, b: Quaternion, t: number ): Quaternion {\n    return new Quaternion( quatSlerp( a.elements, b.elements, t ) );\n  }\n\n  /**\n   * Return a quaternion which rotates around x axis.\n   * @param theta An angle around x axis, in degree\n   */\n  public static rotationX( theta: number ): Quaternion {\n    return new Quaternion( quatRotationX( theta ) );\n  }\n\n  /**\n   * Return a quaternion which rotates around y axis.\n   * @param theta An angle around y axis, in degree\n   */\n  public static rotationY( theta: number ): Quaternion {\n    return new Quaternion( quatRotationY( theta ) );\n  }\n\n  /**\n   * Return a quaternion which rotates around z axis.\n   * @param theta An angle around z axis, in degree\n   */\n  public static rotationZ( theta: number ): Quaternion {\n    return new Quaternion( quatRotationZ( theta ) );\n  }\n\n  /**\n   * Return a quaternion which looks at the direction of `look`.\n   * @param look Position where the quaternion will look at\n   * @param up The \"up vector\"\n   */\n  public static lookRotation( look: Vector3, up: Vector3 ): Quaternion {\n    return new Quaternion( quatLookRotation( look.elements, up.elements ) );\n  }\n\n  /**\n   * Generate a Quaternion out of angle and axis.\n   */\n  public static fromAxisAngle( axis: Vector3, angle: number ): Quaternion {\n    return new Quaternion( quatFromAxisAngle( axis.elements, angle ) );\n  }\n\n  /**\n   * Generate a Quaternion out of a rotation matrix.\n   */\n  public static fromMatrix4( matrix: Matrix4 ): Quaternion {\n    return new Quaternion( quatFromMatrix4( matrix.elements ) );\n  }\n}\n", "/**\n * GLSL Style `mod` function.\n * \"compute value of one parameter modulo another\"\n */\nexport function mod( value: number, divisor: number ): number {\n  return value - Math.floor( value / divisor ) * divisor;\n}\n", "import { mod } from './mod';\n\n/**\n * Enclose arbitrary angle (in radian) into [-\u03C0, \u03C0)\n */\nexport function sanitizeAngle( angle: number ): number {\n  return mod( angle + Math.PI, 2.0 * Math.PI ) - Math.PI;\n}\n", "import { clamp } from '../utils';\nimport { sanitizeAngle } from '../sanitizeAngle';\nimport { vecManhattanLength } from '../vec/vecManhattanLength';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a euler angles out of a matrix3.\n * Make sure the input matrix is normalized.\n *\n * @param m An input rotation matrix\n * @param order An order of output euler angles. Assume as `XYZ` if not specified\n */\nexport function eulerFromMat3( m: RawMatrix3, order?: EulerOrder ): RawVector3 {\n  const [ i, j, k, sign ] =\n    !order || order === 'XYZ' ? [ 0, 1, 2, 1 ] :\n    order === 'XZY' ? [ 0, 2, 1, -1 ] :\n    order === 'YXZ' ? [ 1, 0, 2, -1 ] :\n    order === 'YZX' ? [ 1, 2, 0, 1 ] :\n    order === 'ZXY' ? [ 2, 0, 1, 1 ] :\n    [ 2, 1, 0, -1 ];\n\n  const result: RawVector3 = [ 0.0, 0.0, 0.0 ];\n\n  const c = m[ k + i * 3 ];\n  result[ j ] = -sign * Math.asin( clamp( c, -1.0, 1.0 ) );\n\n  if ( Math.abs( c ) < 0.999999 ) {\n    result[ i ] = sign * Math.atan2( m[ k + j * 3 ], m[ k * 4 ] );\n    result[ k ] = sign * Math.atan2( m[ j + i * 3 ], m[ i * 4 ] );\n  } else {\n    // \"y is 90deg\" cases\n    result[ i ] = sign * Math.atan2( -m[ j + k * 3 ], m[ j * 4 ] );\n  }\n\n  if ( vecManhattanLength( result ) > 1.5 * Math.PI ) {\n    // \"two big revolutions\" cases\n    result[ i ] = sanitizeAngle( result[ i ] + Math.PI );\n    result[ j ] = sanitizeAngle( Math.PI - result[ j ] );\n    result[ k ] = sanitizeAngle( result[ k ] + Math.PI );\n  }\n\n  return result;\n}\n", "import { eulerFromMat3 } from './eulerFromMat3';\nimport { mat3FromMat4 } from '../mat3/mat3FromMat4';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a euler angles out of a matrix4.\n * Make sure the input matrix is normalized.\n *\n * @param m An input rotation matrix\n * @param order An order of output euler angles. Assume as `XYZ` if not specified\n */\nexport function eulerFromMat4( m: RawMatrix4, order?: EulerOrder ): RawVector3 {\n  return eulerFromMat3( mat3FromMat4( m ), order );\n}\n", "import { eulerFromMat3 } from './eulerFromMat3';\nimport { mat3FromQuaternion } from '../mat3/mat3FromQuaternion';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawQuaternion } from '../quat/RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a euler angles out of a quaternion.\n *\n * @param m An input quaternion\n * @param order An order of output euler angles. Assume as `XYZ` if not specified\n */\nexport function eulerFromQuaternion( m: RawQuaternion, order?: EulerOrder ): RawVector3 {\n  return eulerFromMat3( mat3FromQuaternion( m ), order );\n}\n", "import type { EulerOrder } from '../euler/EulerOrder';\nimport type { RawQuaternion } from './RawQuaternion';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Generate a Quaternion out of euler angles.\n */\nexport function quatFromEuler( euler: RawVector3, order?: EulerOrder ): RawQuaternion {\n  const [ i, j, k, sign ] =\n    !order || order === 'XYZ' ? [ 0, 1, 2, 1 ] :\n    order === 'XZY' ? [ 0, 2, 1, -1 ] :\n    order === 'YXZ' ? [ 1, 0, 2, -1 ] :\n    order === 'YZX' ? [ 1, 2, 0, 1 ] :\n    order === 'ZXY' ? [ 2, 0, 1, 1 ] :\n    [ 2, 1, 0, -1 ];\n\n  const ti = 0.5 * euler[ i ];\n  const tj = 0.5 * sign * euler[ j ];\n  const tk = 0.5 * euler[ k ];\n\n  const ci = Math.cos( ti );\n  const cj = Math.cos( tj );\n  const ck = Math.cos( tk );\n  const si = Math.sin( ti );\n  const sj = Math.sin( tj );\n  const sk = Math.sin( tk );\n\n  const result: RawQuaternion = [\n    0.0,\n    0.0,\n    0.0,\n    ck * cj * ci + sk * sj * si,\n  ];\n  result[ i ] = ck * cj * si - sk * sj * ci;\n  result[ j ] = sign * ( ck * sj * ci + sk * cj * si );\n  result[ k ] = sk * cj * ci - ck * sj * si;\n\n  return result;\n}\n", "import { Matrix3 } from '../mat3/Matrix3';\nimport { Matrix4 } from '../mat4/Matrix4';\nimport { Quaternion } from '../quat/Quaternion';\nimport { eulerFromMat3 } from './eulerFromMat3';\nimport { eulerFromMat4 } from './eulerFromMat4';\nimport { eulerFromQuaternion } from './eulerFromQuaternion';\nimport { quatFromEuler } from '../quat/quatFromEuler';\nimport type { EulerOrder } from './EulerOrder';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * An Euler rotations.\n */\nexport class Euler {\n  public elements: RawVector3; // [ x, y, z ]\n\n  /**\n   * An order of this euler.\n   * 'XYZ' by default.\n   *\n   * Note that this is **extrinsic** rotations (which is same as Blender, Maya, and Unity).\n   * Three.js uses intrinsic rotations so you have to reverse the order if you want to match the behavior with Three.js.\n   */\n  public order: EulerOrder;\n\n  public constructor( elements: RawVector3 = [ 0.0, 0.0, 0.0 ], order: EulerOrder = 'XYZ' ) {\n    this.elements = elements;\n    this.order = order;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  /**\n   * An y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  /**\n   * An z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  public toString(): string {\n    return `Euler( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) } (${ this.order }) )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Euler {\n    return new Euler( this.elements.concat() as RawVector3, this.order );\n  }\n\n  /**\n   * Itself but converted into a Quaternion.\n   */\n  public get quaternion(): Quaternion {\n    return new Quaternion( quatFromEuler( this.elements, this.order ) );\n  }\n\n  /**\n   * Itself but converted into a Matrix4.\n   */\n  public get matrix4(): Matrix4 {\n    return this.quaternion.matrix4;\n  }\n\n  /**\n   * Generate an Euler out of a matrix3.\n   */\n  public static fromMatrix3( matrix: Matrix3, order: EulerOrder ): Euler {\n    return new Euler( eulerFromMat3( matrix.elements, order ), order );\n  }\n\n  /**\n   * Generate an Euler out of a matrix4.\n   */\n  public static fromMatrix4( matrix: Matrix4, order: EulerOrder ): Euler {\n    return new Euler( eulerFromMat4( matrix.elements, order ), order );\n  }\n\n  /**\n   * Generate an Euler out of a quaternion.\n   */\n  public static fromQuaternion( quaternion: Quaternion, order: EulerOrder ): Euler {\n    return new Euler( eulerFromQuaternion( quaternion.elements, order ), order );\n  }\n}\n", "import { vecDot } from '../vec/vecDot';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawRay3 } from './RawRay3';\nimport type { RawSphere3 } from '../sphere3/RawSphere3';\n\n/**\n * Return distances from given ray to sphere.\n *\n * The returning distance can be negative.\n *\n * The first returning value will be the distance of the incident point.\n * If the ray does not intersect with sphere, it will return `null`.\n *\n * @param ray A ray\n * @param sphere A target sphere\n */\nexport function ray3DistanceToSphere(\n  [ ro, rd ]: RawRay3,\n  sphere: RawSphere3,\n): [ number, number ] | null {\n  const v = vecSub( ro, sphere[ 0 ] );\n  const b = vecDot( v, rd );\n  const c = vecDot( v, v ) - sphere[ 1 ];\n  const d = b * b - c;\n\n  if ( d < 0.0 ) { return null; }\n\n  const sqrtD = Math.sqrt( d );\n\n  return [ -b - sqrtD, -b + sqrtD ];\n}\n", "import { vecSub } from '../vec/vecSub';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a vector that represents delta of given line.\n *\n * @param line A line\n */\nexport function line3Delta( line: RawLine3 ): RawVector3 {\n  return vecSub( line[ 1 ], line[ 0 ] );\n}\n", "import { line3Delta } from '../line3/line3Delta';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport type { RawLine3 } from '../line3/RawLine3';\nimport type { RawRay3 } from './RawRay3';\n\n/**\n * Convert the given line to a ray.\n *\n * @param line A line\n */\nexport function ray3FromLine3( line: RawLine3 ): RawRay3 {\n  return [\n    line[ 0 ],\n    vecNormalize( line3Delta( line ) ),\n  ];\n}\n", "import { Line3 } from '../line3/Line3';\nimport { Sphere3 } from '../sphere3/Sphere3';\nimport { Vector3 } from '../vec3/Vector3';\nimport { ray3DistanceToSphere } from './ray3DistanceToSphere';\nimport { ray3FromLine3 } from './ray3FromLine3';\nimport type { RawRay3 } from './RawRay3';\n\n/**\n * A 3D ray.\n */\nexport class Ray3 {\n  /**\n   * The origin of the ray.\n   */\n  public origin: Vector3;\n\n  /**\n   * The direction of the ray.\n   * Make sure the direction is normalized.\n   */\n  public direction: Vector3;\n\n  public constructor( start: Vector3 = Vector3.zero, end: Vector3 = Vector3.pz ) {\n    this.origin = start;\n    this.direction = end;\n  }\n\n  /**\n   * Itself but {@link RawRay3} form.\n   */\n  public get raw(): RawRay3 {\n    return [ this.origin.elements, this.direction.elements ];\n  }\n\n  /**\n   * Return distances from given ray to sphere.\n   *\n   * The returning distance can be negative.\n   *\n   * The first returning value will be the distance of the incident point.\n   * If the ray does not intersect with sphere, it will return `null`.\n   *\n   * @param sphere A target sphere\n   */\n  public distanceToSphere( sphere: Sphere3 ): [ number, number ] | null {\n    return ray3DistanceToSphere( this.raw, sphere.raw );\n  }\n\n  /**\n   * Convert {@link RawRay3} to class form.\n   * @param ray A {@link RawRay3}\n   */\n  public static fromRaw( ray: RawRay3 ): Ray3 {\n    return new Ray3( new Vector3( ray[ 0 ] ), new Vector3( ray[ 1 ] ) );\n  }\n\n  /**\n   * Create a ray out of a line.\n   *\n   * @param line A {@link Line3}\n   */\n  public static fromLine3( line: Line3 ): Ray3 {\n    return Ray3.fromRaw( ray3FromLine3( line.raw ) );\n  }\n}\n", "import { vec3ApplyMatrix4 } from '../vec3/vec3ApplyMatrix4';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\n\n/**\n * Apply given matrix4 to given line.\n *\n * @param line A line\n * @param matrix A matrix4 which will be applied to the line\n */\nexport function line3ApplyMatrix4(\n  [ start, end ]: RawLine3,\n  matrix: RawMatrix4,\n): RawLine3 {\n  return [\n    vec3ApplyMatrix4( start, matrix ),\n    vec3ApplyMatrix4( end, matrix ),\n  ];\n}\n", "import { vecAdd } from '../vec/vecAdd';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a vector that represents a certain point of given line.\n * Same as start at t = 0, same as end at t = 1.\n *\n * @param line A line\n * @param t A parameter t\n */\nexport function line3At( line: RawLine3, t: number ): RawVector3 {\n  return vecAdd(\n    vecScale( line[ 0 ], 1.0 - t ),\n    vecScale( line[ 1 ], t ),\n  );\n}\n", "import { line3At } from './line3At';\nimport { saturate } from '../utils';\nimport { vecDot } from '../vec/vecDot';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a point that is on the given line which is closest to the given point.\n *\n * If `segment` is true, it will treat the line as a segment which has start and end.\n * Otherwise it will treat the line is infinite.\n *\n * @param line A line\n * @param point A point\n * @param segment Is the line a segment?\n */\nexport function line3ClosestPointToPoint(\n  line: RawLine3,\n  point: RawVector3,\n  segment?: boolean,\n): RawVector3 {\n  const ap = vecSub( point, line[ 0 ] );\n  const ab = vecSub( line[ 1 ], line[ 0 ] );\n\n  let t = vecDot( ap, ab ) / vecDot( ab, ab );\n  segment && ( t = saturate( t ) );\n\n  return line3At( line, t );\n}\n", "import { line3ClosestPointToPoint } from './line3ClosestPointToPoint';\nimport { vecLength } from '../vec/vecLength';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawLine3 } from './RawLine3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a distance from the given line to the given point.\n *\n * If `segment` is true, it will treat the line as a segment which has start and end.\n * Otherwise it will treat the line is infinite.\n *\n * @param line A line\n * @param point A point\n * @param segment Is the line a segment?\n */\nexport function line3DistanceToPoint(\n  line: RawLine3,\n  point: RawVector3,\n  segment?: boolean,\n): number {\n  return vecLength( vecSub(\n    line3ClosestPointToPoint( line, point, segment ),\n    point,\n  ) );\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Ray3 } from '../ray3/Ray3';\nimport { Vector3 } from '../vec3/Vector3';\nimport { line3ApplyMatrix4 } from './line3ApplyMatrix4';\nimport { line3At } from './line3At';\nimport { line3ClosestPointToPoint } from './line3ClosestPointToPoint';\nimport { line3Delta } from './line3Delta';\nimport { line3DistanceToPoint } from './line3DistanceToPoint';\nimport type { RawLine3 } from './RawLine3';\n\n/**\n * A 3D line.\n */\nexport class Line3 {\n  public start: Vector3;\n  public end: Vector3;\n\n  public constructor( start: Vector3 = Vector3.zero, end: Vector3 = Vector3.zero ) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Itself but {@link RawLine3} form.\n   */\n  public get raw(): RawLine3 {\n    return [ this.start.elements, this.end.elements ];\n  }\n\n  /**\n   * Itself but a ray.\n   */\n  public get ray(): Ray3 {\n    return Ray3.fromLine3( this );\n  }\n\n  /**\n   * A vector that represents delta of the line.\n   */\n  public delta(): Vector3 {\n    return new Vector3( line3Delta( this.raw ) );\n  }\n\n  /**\n   * Its length.\n   */\n  public length(): number {\n    return this.delta.length;\n  }\n\n  /**\n   * Return a vector that represents a certain point of the line.\n   * Same as start at t = 0, same as end at t = 1.\n   *\n   * @param t A parameter t\n   */\n  public at( t: number ): Vector3 {\n    return new Vector3( line3At( this.raw, t ) );\n  }\n\n  /**\n   * Apply given matrix4 to the line.\n   *\n   * @param matrix A matrix4 which will be applied to the line\n   */\n  public applyMatrix4( matrix: Matrix4 ): Line3 {\n    return Line3.fromRaw(\n      line3ApplyMatrix4(\n        this.raw,\n        matrix.elements,\n      )\n    );\n  }\n\n  /**\n   * Return a point that is on the line which is closest to the given point.\n   *\n   * If `segment` is true, it will treat the line as a segment which has start and end.\n   * Otherwise it will treat the line is infinite.\n   *\n   * @param point A point\n   * @param segment Is the line a segment?\n   */\n  public closestPointToPoint( point: Vector3, segment: boolean ): Vector3 {\n    return new Vector3( line3ClosestPointToPoint( this.raw, point.elements, segment ) );\n  }\n\n  /**\n   * Return a distance from the line to the given point.\n   *\n   * If `segment` is true, it will treat the line as a segment which has start and end.\n   * Otherwise it will treat the line is infinite.\n   *\n   * @param point A point\n   * @param segment Is the line a segment?\n   */\n  public distanceToPoint( point: Vector3, segment: boolean ): number {\n    return line3DistanceToPoint( this.raw, point.elements, segment );\n  }\n\n  /**\n   * Convert {@link RawLine3} to class form.\n   * @param line A {@link RawLine3}\n   */\n  public static fromRaw( line: RawLine3 ): Line3 {\n    return new Line3( new Vector3( line[ 0 ] ), new Vector3( line[ 1 ] ) );\n  }\n}\n", "import type { RawMatrix2 } from './RawMatrix2';\n\nexport function mat2Determinant( m: RawMatrix2 ): number {\n  return m[ 0 ] * m[ 3 ] - m[ 2 ] * m[ 1 ];\n}\n", "import { vecScale } from '../vec/vecScale';\nimport type { RawMatrix2 } from './RawMatrix2';\n\n/**\n * Return an inverse of given matrix.\n */\nexport function mat2Inverse( m: RawMatrix2 ): RawMatrix2 {\n  const\n    n11 = m[ 0 ], n21 = m[ 1 ],\n    n12 = m[ 2 ], n22 = m[ 3 ],\n    det = n11 * n22 - n12 * n21;\n\n  if ( det === 0.0 ) { return vecScale( m, 0.0 ); }\n\n  return vecScale( [\n    n22, -n21,\n    -n12, n11,\n  ], 1.0 / det );\n}\n", "import type { RawMatrix2 } from './RawMatrix2';\n\n/**\n * Return a multiplication result of matrices.\n */\nexport function mat2Multiply( ...mats: RawMatrix2[] ): RawMatrix2 {\n  if ( mats.length < 2 ) {\n    return mats[ 0 ];\n  }\n\n  const a = mats.shift()!;\n  const b = mat2Multiply( ...mats );\n  const\n    a00 = a[ 0 ], a01 = a[ 1 ],\n    a10 = a[ 2 ], a11 = a[ 3 ],\n    b00 = b[ 0 ], b01 = b[ 1 ],\n    b10 = b[ 2 ], b11 = b[ 3 ];\n\n  return [\n    a00 * b00 + a10 * b01,\n    a01 * b00 + a11 * b01,\n\n    a00 * b10 + a10 * b11,\n    a01 * b10 + a11 * b11,\n  ];\n}\n", "import type { RawMatrix2 } from './RawMatrix2';\n\n/**\n * Transpose a mat2.\n */\nexport function mat2Transpose(\n  source: RawMatrix2,\n): RawMatrix2 {\n  return [\n    source[ 0 ], source[ 2 ],\n    source[ 1 ], source[ 3 ],\n  ];\n}\n", "import { mat2Determinant } from './mat2Determinant';\nimport { mat2Inverse } from './mat2Inverse';\nimport { mat2Multiply } from './mat2Multiply';\nimport { mat2Transpose } from './mat2Transpose';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix2 } from './RawMatrix2';\n\nconst rawIdentityMatrix2: RawMatrix2 = [\n  1.0, 0.0,\n  0.0, 1.0,\n];\n\n/**\n * A Matrix2.\n */\nexport class Matrix2 {\n  public elements: RawMatrix2;\n\n  public constructor( v: RawMatrix2 = rawIdentityMatrix2 ) {\n    this.elements = v;\n  }\n\n  /**\n   * Itself but transposed.\n   */\n  public get transpose(): Matrix2 {\n    return new Matrix2( mat2Transpose( this.elements ) );\n  }\n\n  /**\n   * Its determinant.\n   */\n  public get determinant(): number {\n    return mat2Determinant( this.elements );\n  }\n\n  /**\n   * Itself but inverted.\n   */\n  public get inverse(): Matrix2 {\n    return new Matrix2( mat2Inverse( this.elements ) );\n  }\n\n  public toString(): string {\n    const m = this.elements.map( ( v ) => v.toFixed( 3 ) );\n    return `Matrix2( ${ m[ 0 ] }, ${ m[ 2 ] }; ${ m[ 1 ] }, ${ m[ 3 ] } )`;\n  }\n\n  /**\n   * Clone this.\n   */\n  public clone(): Matrix2 {\n    return new Matrix2( this.elements.concat() as RawMatrix2 );\n  }\n\n  /**\n   * Multiply this Matrix2 by one or more Matrix2s.\n   */\n  public multiply( ...matrices: Matrix2[] ): Matrix2 {\n    return Matrix2.multiply( this, ...matrices );\n  }\n\n  /**\n   * Multiply this Matrix3 by a scalar.\n   */\n  public scaleScalar( scalar: number ): Matrix2 {\n    return new Matrix2( vecScale( this.elements, scalar ) );\n  }\n\n  /**\n   * An identity Matrix4.\n   */\n  public static get identity(): Matrix2 {\n    return new Matrix2( rawIdentityMatrix2 );\n  }\n\n  /**\n   * Multiply two or more matrices.\n   * @param matrices Matrices\n   */\n  public static multiply( ...matrices: Matrix2[] ): Matrix2 {\n    if ( matrices.length === 0 ) {\n      return Matrix2.identity;\n    } else {\n      return new Matrix2( mat2Multiply( ...matrices.map( ( m ) => m.elements ) ) );\n    }\n  }\n}\n", "import type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawVector3 } from './RawVector3';\n\n/**\n * Apply a vec3 a mat3.\n */\nexport function vec3ApplyMatrix3( v: RawVector3, m: RawMatrix3 ): RawVector3 {\n  return [\n    m[ 0 ] * v[ 0 ] + m[ 3 ] * v[ 1 ] + m[ 6 ] * v[ 2 ],\n    m[ 1 ] * v[ 0 ] + m[ 4 ] * v[ 1 ] + m[ 7 ] * v[ 2 ],\n    m[ 2 ] * v[ 0 ] + m[ 5 ] * v[ 1 ] + m[ 8 ] * v[ 2 ],\n  ];\n}\n", "import { vec3ApplyMatrix3 } from '../vec3/vec3ApplyMatrix3';\nimport { vec3ApplyMatrix4 } from '../vec3/vec3ApplyMatrix4';\nimport { vecDot } from '../vec/vecDot';\nimport { vecNormalize } from '../vec/vecNormalize';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Apply given matrix4 to given plane.\n *\n * @param plane A plane\n * @param matrix A matrix4 which will be applied to the plane\n * @param normalMatrix A normalMatrix made out of {@link matrix}\n */\nexport function plane3ApplyMatrix4(\n  [ normal, distance ]: RawPlane3,\n  matrix: RawMatrix4,\n  normalMatrix: RawMatrix3,\n): RawPlane3 {\n  // normal\u306A\u3093\u3060\u304B\u3089normalMatrix\u5F53\u3066\u308C\u3070\u30E8\u30B7\uFF01\n  const newNormal = vecNormalize( vec3ApplyMatrix3( normal, normalMatrix ) );\n\n  // \u3068\u308A\u3042\u3048\u305A\u4E00\u70B9\u89B3\u6E2C\u3057\u3066\u3042\u3068\u3067dot\u53D6\u308A\u76F4\u3057\u3061\u3083\u304A\u3046\u305C\uFF01\n  const coplanar = vecScale( normal, -distance );\n  const refPoint = vec3ApplyMatrix4( coplanar, matrix );\n  const newDistance = -vecDot( refPoint, normal );\n\n  return [ newNormal, newDistance ];\n}\n", "import { vecDot } from '../vec/vecDot';\nimport type { RawPlane3 } from './RawPlane3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Return a signed distance from given plane to the given point.\n * Make sure the `normal` is normalized.\n */\nexport function plane3DistanceToPoint(\n  [ normal, distance ]: RawPlane3,\n  point: RawVector3,\n): number {\n  return vecDot( normal, point ) + distance;\n}\n", "import { vecLength } from '../vec/vecLength';\nimport { vecScale } from '../vec/vecScale';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Normalize a given plane?\n * This normalizes the normal and also divide distance by its original normal length.\n *\n * I don't come up with any use cases other than {@link planesFromProjectionMatrix}.\n *\n * @param plane The plane you want to normalize\n */\nexport function plane3Normalize( [ normal, distance ]: RawPlane3 ): RawPlane3 {\n  const invL = 1.0 / vecLength( normal );\n  return [ vecScale( normal, invL ), distance * invL ];\n}\n", "import { Matrix3 } from '../mat3/Matrix3';\nimport { Matrix4 } from '../mat4/Matrix4';\nimport { Vector3 } from '../vec3/Vector3';\nimport { plane3ApplyMatrix4 } from './plane3ApplyMatrix4';\nimport { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport { plane3Normalize } from './plane3Normalize';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * A 3D plane.\n */\nexport class Plane3 {\n  public normal: Vector3;\n  public distance: number;\n\n  /**\n   * Itself but {@link RawPlane3} form.\n   */\n  public get raw(): RawPlane3 {\n    return [ this.normal.elements, this.distance ];\n  }\n\n  /**\n   * Normalized plane?\n   * This normalizes the normal and also divide distance by its original normal length.\n   */\n  public get normalized(): Plane3 {\n    return Plane3.fromRaw( plane3Normalize( this.raw ) );\n  }\n\n  public constructor( normal: Vector3 = Vector3.pz, distance = 0.0 ) {\n    this.normal = normal;\n    this.distance = distance;\n  }\n\n  /**\n   * Apply given matrix4 to the plane.\n   *\n   * @param matrix A matrix4 which will be applied to the plane\n   * @param normalMatrix A normalMatrix made out of {@link matrix}. Optional\n   */\n  public applyMatrix4( matrix: Matrix4, normalMatrix?: Matrix3 ): Plane3 {\n    return Plane3.fromRaw(\n      plane3ApplyMatrix4(\n        this.raw,\n        matrix.elements,\n        normalMatrix?.elements ?? matrix.normalMatrix.elements,\n      )\n    );\n  }\n\n  /**\n   * Return a signed distance from given plane to the given point.\n   *\n   * @param point A point\n   */\n  public distanceToPoint( point: Vector3 ): number {\n    return plane3DistanceToPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Convert {@link RawPlane3} to class form.\n   * @param plane A {@link RawPlane3}\n   */\n  public static fromRaw( plane: RawPlane3 ): Plane3 {\n    return new Plane3( new Vector3( plane[ 0 ] ), plane[ 1 ] );\n  }\n}\n", "import { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport type { RawPlane3 } from './RawPlane3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given point is contained in given planes or not.\n *\n * @param planes A list of planes\n * @param point A point\n */\nexport function planes3ContainPoint( planes: RawPlane3[], point: RawVector3 ): boolean {\n  return planes.every( ( plane ) => plane3DistanceToPoint( plane, point ) >= 0.0 );\n}\n", "import type { RawBox3 } from '../box3/RawBox3';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Generate a set of plane3 out of a {@link RawBox3}.\n *\n * @param box A box\n */\nexport function planes3FromBox3( box: RawBox3 ): RawPlane3[] {\n  return [\n    [ [ 1.0, 0.0, 0.0 ], -box[ 0 ][ 0 ] ], // xn\n    [ [ -1.0, 0.0, 0.0 ], box[ 1 ][ 0 ] ], // xp\n    [ [ 0.0, 1.0, 0.0 ], -box[ 0 ][ 1 ] ], // yn\n    [ [ 0.0, -1.0, 0.0 ], box[ 1 ][ 1 ] ], // yp\n    [ [ 0.0, 0.0, 1.0 ], -box[ 0 ][ 2 ] ], // yn\n    [ [ 0.0, 0.0, -1.0 ], box[ 1 ][ 2 ] ], // yp\n  ];\n}\n", "import { plane3Normalize } from './plane3Normalize';\nimport type { RawMatrix4 } from '../mat4/RawMatrix4';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Create frustum planes out of given projection matrix.\n *\n * @param m A projection matrix\n */\nexport function planes3FromProjectionMatrix( m: RawMatrix4 ): RawPlane3[] {\n  const\n    m11 = m[ 0 ], m12 = m[ 4 ], m13 = m[ 8 ], m14 = m[ 12 ],\n    m21 = m[ 1 ], m22 = m[ 5 ], m23 = m[ 9 ], m24 = m[ 13 ],\n    m31 = m[ 2 ], m32 = m[ 6 ], m33 = m[ 10 ], m34 = m[ 14 ],\n    m41 = m[ 3 ], m42 = m[ 7 ], m43 = m[ 11 ], m44 = m[ 15 ];\n\n  return [\n    plane3Normalize( [ [ m41 - m11, m42 - m12, m43 - m13 ], m44 - m14 ] ), // xp\n    plane3Normalize( [ [ m41 + m11, m42 + m12, m43 + m13 ], m44 + m14 ] ), // xn\n    plane3Normalize( [ [ m41 - m21, m42 - m22, m43 - m23 ], m44 - m24 ] ), // yp\n    plane3Normalize( [ [ m41 + m21, m42 + m22, m43 + m23 ], m44 + m24 ] ), // yn\n    plane3Normalize( [ [ m41 - m31, m42 - m32, m43 - m33 ], m44 - m34 ] ), // zn\n    plane3Normalize( [ [ m41 + m31, m42 + m32, m43 + m33 ], m44 + m34 ] ), // zp\n  ];\n}\n", "import { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport type { RawBox3 } from '../box3/RawBox3';\nimport type { RawPlane3 } from './RawPlane3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given box intersects with planes or not.\n *\n * @param planes A list of planes\n * @param box A box3\n */\nexport function planes3IntersectBox3( planes: RawPlane3[], box: RawBox3 ): boolean {\n  return planes.every( ( plane ) => {\n    const v = plane[ 0 ].map( ( nc, i ) => box[ nc > 0.0 ? 1 : 0 ][ i ] ) as RawVector3;\n    return plane3DistanceToPoint( plane, v ) >= 0.0;\n  } );\n}\n", "import { RawSphere3 } from '../sphere3/RawSphere3';\nimport { plane3DistanceToPoint } from './plane3DistanceToPoint';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * Test if given sphere intersects with planes or not.\n *\n * It does not do strict intersection test but still should work well with frustum cull use cases.\n * See the test case for more details.\n *\n * @param planes A list of planes\n * @param sphere A sphere3\n */\nexport function planes3IntersectSphere3( planes: RawPlane3[], sphere: RawSphere3 ): boolean {\n  return planes.every( ( plane ) => (\n    plane3DistanceToPoint( plane, sphere[ 0 ] ) >= -sphere[ 1 ]\n  ) );\n}\n", "import { Box3 } from '../box3/Box3';\nimport { Matrix4 } from '../mat4/Matrix4';\nimport { Plane3 } from './Plane3';\nimport { Sphere3 } from '../sphere3/Sphere3';\nimport { Vector3 } from '../vec3/Vector3';\nimport { planes3ContainPoint } from './planes3ContainPoint';\nimport { planes3FromBox3 } from './planes3FromBox3';\nimport { planes3FromProjectionMatrix } from './planes3FromProjectionMatrix';\nimport { planes3IntersectBox3 } from './planes3IntersectBox3';\nimport { planes3IntersectSphere3 } from './planes3IntersectSphere3';\nimport type { RawPlane3 } from './RawPlane3';\n\n/**\n * A set of {@link Plane3}.\n */\nexport class Planes3 {\n  public planes: Plane3[];\n\n  /**\n   * Itself but {@link RawPlane3}[] form.\n   */\n  public get raw(): RawPlane3[] {\n    return this.planes.map( ( plane ) => plane.raw );\n  }\n\n  public constructor( planes: Plane3[] ) {\n    this.planes = planes;\n  }\n\n  /**\n   * Test if given point is contained in the planes or not.\n   *\n   * @param point A point\n   */\n  public containPoint( point: Vector3 ): boolean {\n    return planes3ContainPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Test if given box intersects with the planes or not.\n   *\n   * @param box A box3\n   */\n  public intersectBox3( box: Box3 ): boolean {\n    return planes3IntersectBox3( this.raw, box.raw );\n  }\n\n  /**\n   * Test if given sphere intersects with the planes or not.\n   *\n   * It does not do strict intersection test but still should work well with frustum cull use cases.\n   * See the test case for more details.\n   *\n   * @param sphere A sphere3\n   */\n  public intersectSphere3( sphere: Sphere3 ): boolean {\n    return planes3IntersectSphere3( this.raw, sphere.raw );\n  }\n\n  /**\n   * Convert {@link RawPlane3}[] to class form.\n   *\n   * @param planes A {@link RawPlane3}[]\n   */\n  public static fromRaw( planes: RawPlane3[] ): Planes3 {\n    return new Planes3( planes.map( ( plane ) => Plane3.fromRaw( plane ) ) );\n  }\n\n  /**\n   * Generate a set of plane3 out of a {@link RawBox3}.\n   *\n   * @param box A box\n   */\n  public static fromBox3( box: Box3 ): Planes3 {\n    return Planes3.fromRaw( planes3FromBox3( box.raw ) );\n  }\n\n  /**\n   * Create frustum planes out of given projection matrix.\n   *\n   * @param matrix A projection matrix\n   */\n  public static fromProjectionMatrix( matrix: Matrix4 ): Planes3 {\n    return Planes3.fromRaw( planes3FromProjectionMatrix( matrix.elements ) );\n  }\n}\n", "import { vecLengthSq } from '../vec/vecLengthSq';\nimport { vecSub } from '../vec/vecSub';\nimport type { RawSphere3 } from './RawSphere3';\nimport type { RawVector3 } from '../vec3/RawVector3';\n\n/**\n * Test if given point is contained in given sphere or not.\n * @param sphere A sphere\n * @param point A point\n */\nexport function sphere3ContainsPoint( sphere: RawSphere3, point: RawVector3 ): boolean {\n  return vecLengthSq( vecSub( sphere[ 0 ], point ) ) <= sphere[ 1 ] * sphere[ 1 ];\n}\n", "import { Vector3 } from '../vec3/Vector3';\nimport { sphere3ContainsPoint } from './sphere3ContainsPoint';\nimport type { RawSphere3 } from './RawSphere3';\n\n/**\n * A 3D sphere.\n */\nexport class Sphere3 {\n  public origin: Vector3;\n  public radius: number;\n\n  public constructor( origin: Vector3 = Vector3.zero, radius: number = 0.0 ) {\n    this.origin = origin;\n    this.radius = radius;\n  }\n\n  /**\n   * Itself but {@link RawSphere3} form.\n   */\n  public get raw(): RawSphere3 {\n    return [ this.origin.elements, this.radius ];\n  }\n\n  /**\n   * Test if given point is contained in the sphere or not.\n   *\n   * @param point A point\n   */\n  public containsPoint( point: Vector3 ): boolean {\n    return sphere3ContainsPoint( this.raw, point.elements );\n  }\n\n  /**\n   * Convert {@link RawSphere3} to class form.\n   * @param sphere A {@link RawSphere3}\n   */\n  public static fromRaw( sphere: RawSphere3 ): Sphere3 {\n    return new Sphere3( new Vector3( sphere[ 0 ] ), sphere[ 1 ] );\n  }\n}\n", "import { vec3ApplyMatrix3 } from '../vec3/vec3ApplyMatrix3';\nimport type { RawMatrix3 } from '../mat3/RawMatrix3';\nimport type { RawVector3 } from '../vec3/RawVector3';\nimport type { RawVector4 } from './RawVector4';\n\n/**\n * Apply a vec4 a mat3 (with an implicit 1 on m44).\n */\nexport function vec4ApplyMatrix3( v: RawVector4, m: RawMatrix3 ): RawVector4 {\n  const v3: RawVector3 = [ v[ 0 ], v[ 1 ], v[ 2 ] ];\n  const xyz = vec3ApplyMatrix3( v3, m );\n  const w = v[ 3 ];\n  return [ xyz[ 0 ], xyz[ 1 ], xyz[ 2 ], w ];\n}\n", "import { Matrix4 } from '../mat4/Matrix4';\nimport { Vector } from '../vec/Vector';\nimport { vec4ApplyMatrix3 } from './vec4ApplyMatrix3';\nimport { vec4ApplyMatrix4 } from './vec4ApplyMatrix4';\nimport type { Matrix3 } from '../mat3/Matrix3';\nimport type { RawVector4 } from './RawVector4';\n\n/**\n * A Vector3.\n */\nexport class Vector4 extends Vector<Vector4> {\n  public elements: RawVector4;\n\n  public constructor( v: RawVector4 = [ 0.0, 0.0, 0.0, 0.0 ] ) {\n    super();\n    this.elements = v;\n  }\n\n  /**\n   * An x component of this.\n   */\n  public get x(): number {\n    return this.elements[ 0 ];\n  }\n\n  public set x( x: number ) {\n    this.elements[ 0 ] = x;\n  }\n\n  /**\n   * A y component of this.\n   */\n  public get y(): number {\n    return this.elements[ 1 ];\n  }\n\n  public set y( y: number ) {\n    this.elements[ 1 ] = y;\n  }\n\n  /**\n   * A z component of this.\n   */\n  public get z(): number {\n    return this.elements[ 2 ];\n  }\n\n  public set z( z: number ) {\n    this.elements[ 2 ] = z;\n  }\n\n  /**\n   * A w component of this.\n   */\n  public get w(): number {\n    return this.elements[ 3 ];\n  }\n\n  public set w( z: number ) {\n    this.elements[ 3 ] = z;\n  }\n\n  public toString(): string {\n    return `Vector4( ${ this.x.toFixed( 3 ) }, ${ this.y.toFixed( 3 ) }, ${ this.z.toFixed( 3 ) }, ${ this.w.toFixed( 3 ) } )`;\n  }\n\n  /**\n   * Apply this vector a mat3 (with an implicit 1 on m44).\n   */\n  public applyMatrix3( matrix: Matrix3 ): Vector4 {\n    return new Vector4( vec4ApplyMatrix3( this.elements, matrix.elements ) );\n  }\n\n  /**\n   * Multiply this vector by a mat4.\n   */\n  public applyMatrix4( matrix: Matrix4 ): Vector4 {\n    return new Vector4( vec4ApplyMatrix4( this.elements, matrix.elements ) );\n  }\n\n  protected __new( v: RawVector4 ): Vector4 {\n    return new Vector4( v );\n  }\n\n  /**\n   * Vector4( 0.0, 0.0, 0.0, 0.0 )\n   */\n  public static get zero(): Vector4 {\n    return new Vector4( [ 0.0, 0.0, 0.0, 0.0 ] );\n  }\n\n  /**\n   * Vector4( 1.0, 1.0, 1.0, 1.0 )\n   */\n  public static get one(): Vector4 {\n    return new Vector4( [ 1.0, 1.0, 1.0, 1.0 ] );\n  }\n}\n", "import { MidiParseResult, MidiParseResultHeader, MidiParseResultTrack } from './MidiParseResult';\nimport { arraySerial } from '../array/arraySerial';\n\nfunction readU8( array: Uint8Array, headBox: [ number ] ): number {\n  return array[ headBox[ 0 ] ++ ];\n}\n\n/**\n * Big endian\n */\nfunction readU16( array: Uint8Array, headBox: [ number ] ): number {\n  return readU8( array, headBox ) * 256 + readU8( array, headBox );\n}\n\n/**\n * Big endian\n */\nfunction readU32( array: Uint8Array, headBox: [ number ] ): number {\n  return readU16( array, headBox ) * 65536 + readU16( array, headBox );\n}\n\nfunction readUVar( array: Uint8Array, headBox: [ number ] ): number {\n  let v = 0;\n  for ( ;; ) {\n    const vv = readU8( array, headBox );\n    v = v * 128 + ( vv & 127 );\n\n    if ( vv < 128 ) {\n      return v;\n    }\n  }\n}\n\nfunction parseHeader( array: Uint8Array, headBox: [ number ] ): MidiParseResultHeader {\n  // skip type and length (4+4)\n  // length has to be 6, there's no need to parse\n  headBox[ 0 ] += 8;\n\n  return [\n    readU16( array, headBox ),\n    readU16( array, headBox ),\n    readU16( array, headBox ),\n  ];\n}\n\nfunction parseTrack( array: Uint8Array, headBox: [ number ] ): MidiParseResultTrack {\n  // skip type (4)\n  headBox[ 0 ] += 4;\n\n  const endOfTrack = headBox[ 0 ] + readU32( array, headBox ) + 4;\n\n  const track: MidiParseResultTrack = [];\n  let type = 0;\n\n  while ( headBox[ 0 ] < endOfTrack ) {\n    const delta = readUVar( array, headBox );\n    const status = readU8( array, headBox );\n    type = status < 128 ? type : status;\n    const data0 = status < 128 ? status : readU8( array, headBox );\n\n    if ( type < 0xc0 ) {\n      // note on (9x), note off (8x), polyphonic key pressure (Ax), control change (Bx)\n\n      track.push( [\n        delta,\n        type,\n        data0, // note or cc number\n        readU8( array, headBox ), // velocity, pressure, or data\n      ] );\n    } else if ( type === 0xff ) {\n      // meta events\n\n      const eventLength = readU8( array, headBox );\n\n      track.push( [\n        delta,\n        type,\n        data0,\n        arraySerial( eventLength ).map( () => readU8( array, headBox ) ),\n      ] );\n\n      if ( data0 === 0x2f ) { // end of track\n        break;\n      }\n    } else {\n      throw new Error( `${ type }` );\n    }\n  }\n\n  return track;\n}\n\nexport function midiParse( buffer: ArrayBuffer ): MidiParseResult {\n  const array = new Uint8Array( buffer );\n  const headBox: [ number ] = [ 0 ];\n\n  const header = parseHeader( array, headBox );\n  const tracks: MidiParseResultTrack[] = [];\n\n  while ( headBox[ 0 ] < array.length ) {\n    tracks.push( parseTrack( array, headBox ) );\n  }\n\n  return [ header, tracks ];\n}\n", "import type { PokerRank } from './PokerRank';\n\nexport const pokerRanksByStrength: PokerRank[] = [\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  'T',\n  'J',\n  'Q',\n  'K',\n  'A',\n];\n", "import type { PokerSuit } from './PokerSuit';\n\nexport const pokerSuitsByIndex: PokerSuit[] = [\n  'c',\n  'd',\n  'h',\n  's',\n];\n", "import { pokerRanksByStrength } from './pokerRanksByStrength';\nimport { pokerSuitsByIndex } from './pokerSuitsByIndex';\nimport type { PokerCard } from './PokerCard';\n\n/**\n * Create a 52-card deck.\n * You might want to use {@link shuffleArray} to shuffle the deck.\n */\nexport function createPokerDeck(): PokerCard[] {\n  const array: PokerCard[] = [];\n\n  pokerSuitsByIndex.map( ( suit ) => (\n    pokerRanksByStrength.map( ( rank ) => (\n      array.push( rank + suit as PokerCard )\n    ) )\n  ) );\n\n  return array;\n}\n", "import { PokerHand } from './PokerHand';\n\nexport const pokerHandStrengthMap: { [ hand in PokerHand ]: number } = {\n  'HighCard': 0,\n  'OnePair': 1,\n  'TwoPair': 2,\n  'ThreeOfAKind': 3,\n  'Straight': 4,\n  'Flush': 5,\n  'FullHouse': 6,\n  'FourOfAKind': 7,\n  'StraightFlush': 8,\n};\n", "import type { PokerRank } from './PokerRank';\n\nexport const pokerRankStrengthMap: { [ rank in PokerRank ]: number } = {\n  '2': 0,\n  '3': 1,\n  '4': 2,\n  '5': 3,\n  '6': 4,\n  '7': 5,\n  '8': 6,\n  '9': 7,\n  'T': 8,\n  'J': 9,\n  'Q': 10,\n  'K': 11,\n  'A': 12\n};\n", "import type { PokerSuit } from './PokerSuit';\n\nexport const pokerSuitIndexMap: { [ suit in PokerSuit ]: number } = {\n  'c': 0,\n  'd': 1,\n  'h': 2,\n  's': 3,\n};\n", "import { pokerRankStrengthMap } from './pokerRankStrengthMap';\nimport { pokerSuitIndexMap } from './pokerSuitIndexMap';\nimport type { PokerCard } from './PokerCard';\nimport type { PokerRank } from './PokerRank';\nimport type { PokerSuit } from './PokerSuit';\n\n/**\n * Sort given array of cards in place by rank (and suit).\n */\nexport function sortPokerCardsByRank( cards: PokerCard[] ): PokerCard[] {\n  return cards\n    .sort( ( a, b ) => (\n      pokerSuitIndexMap[ a[ 1 ] as PokerSuit ] - pokerSuitIndexMap[ b[ 1 ] as PokerSuit ]\n    ) )\n    .sort( ( a, b ) => (\n      pokerRankStrengthMap[ a[ 0 ] as PokerRank ] - pokerRankStrengthMap[ b[ 0 ] as PokerRank ]\n    ) );\n}\n", "import { MapOfSet } from '../MapOfSet/MapOfSet';\nimport { pokerHandStrengthMap } from './pokerHandStrengthMap';\nimport { pokerRankStrengthMap } from './pokerRankStrengthMap';\nimport { pokerRanksByStrength } from './pokerRanksByStrength';\nimport { sortPokerCardsByRank } from './sortPokerCardsByRank';\nimport type { PokerCard } from './PokerCard';\nimport type { PokerHand } from './PokerHand';\nimport type { PokerRank } from './PokerRank';\nimport type { PokerSuit } from './PokerSuit';\n\nexport interface EvaluatePokerHandResult {\n  hand: PokerHand;\n  strength: number[];\n  cards: [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ];\n}\n\nexport function evaluatePokerHand( cards: PokerCard[] ): EvaluatePokerHandResult {\n  // cards mutable edition\n  const cards_ = cards.concat();\n\n  const cardsByRank = new MapOfSet<PokerRank, PokerCard>();\n  const cardsBySuit = new MapOfSet<PokerSuit, PokerCard>();\n\n  cards_.map( ( card ) => {\n    const rank = card[ 0 ] as PokerRank;\n    const suit = card[ 1 ] as PokerSuit;\n    cardsByRank.add( rank, card );\n    cardsBySuit.add( suit, card );\n  } );\n\n  // pairs\n  const fours: PokerRank[] = [];\n  const threes: PokerRank[] = [];\n  const twos: PokerRank[] = [];\n\n  pokerRanksByStrength.map( ( rank ) => {\n    const cards = cardsByRank.get( rank );\n    if ( cards.size > 3 ) {\n      fours.push( rank );\n    } else if ( cards.size > 2 ) {\n      threes.push( rank );\n    } else if ( cards.size > 1 ) {\n      twos.push( rank );\n    }\n  } );\n\n  // straight\n  let straightCards: PokerCard[] | undefined;\n  {\n    let current: PokerCard[] = [];\n\n    // handle steel wheel\n    const a = Array.from( cardsByRank.get( 'A' ) )[ 0 ];\n    if ( a ) {\n      current.push( a );\n    }\n\n    pokerRanksByStrength.map( ( rank ) => {\n      const card = Array.from( cardsByRank.get( rank ) )[ 0 ];\n      if ( card ) {\n        current.push( card );\n\n        if ( current.length > 4 ) {\n          straightCards = current;\n        }\n      } else {\n        current = [];\n      }\n    } );\n  }\n\n  // straight flush\n  if ( straightCards ) {\n    for ( const [ suit, cardsSet ] of cardsBySuit.map ) {\n      if ( cardsSet.size > 0 ) {\n        let straightFlushCards: PokerCard[] | undefined;\n        let current: PokerCard[] = [];\n\n        // handle steel wheel\n        const target = 'A' + suit as PokerCard;\n        const a = cardsSet.has( target );\n        if ( a ) {\n          current.push( target );\n        }\n\n        pokerRanksByStrength.map( ( rank ) => {\n          const target = rank + suit as PokerCard;\n          if ( cardsSet.has( target ) ) {\n            current.push( target );\n\n            if ( current.length > 4 ) {\n              straightFlushCards = current;\n            }\n          } else {\n            current = [];\n          }\n        } );\n\n        if ( straightFlushCards ) {\n          straightFlushCards.splice( 0, straightFlushCards.length - 5 );\n\n          const hand = 'StraightFlush';\n          const strength = [\n            pokerHandStrengthMap[ hand ],\n            pokerRankStrengthMap[ straightFlushCards[ 4 ][ 0 ] as PokerRank ],\n          ];\n\n          return {\n            hand,\n            cards: straightFlushCards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n            strength,\n          };\n        }\n      }\n    }\n  }\n\n  // four of a kind\n  if ( fours.length > 0 ) {\n    fours.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    fours.splice( 0, fours.length - 1 );\n\n    // 5s, 5c, Kd, 6d, 9c, 5d, 5h\n\n    const sameCards = Array.from( cardsByRank.get( fours[ 0 ] ) );\n    sameCards.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // Kd, 6d, 9c\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 1 );\n    // Kd\n\n    const hand = 'FourOfAKind';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ fours[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...sameCards );\n    sortPokerCardsByRank( cards_ );\n    // 5c, 5d, 5h, 5s, Kd\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // full house\n  if ( threes.length > 0 && threes.length + twos.length > 1 ) {\n    threes.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n\n    // tricky part: it is possible to have two or more threes at once\n    // just transfer threes which is not highest\n    // and wish we'll do this right in the rest of the code\n    twos.push( ...threes.splice( 0, threes.length - 1 ) );\n\n    twos.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    twos.splice( 0, twos.length - 1 );\n\n    // 7d, 7s, Tc, Td, 7h, 9d, Th\n\n    const sameCards = Array.from( cardsByRank.get( threes[ 0 ] ) );\n    sameCards.push( ...Array.from( cardsByRank.get( twos[ 0 ] ) ) );\n    // sameCards: Tc, Td, Th, 7d, 7s, 7h\n\n    sortPokerCardsByRank( sameCards ).splice( 0, sameCards.length - 5 );\n    // sameCards: 7h, 7s, Tc, Td, Th\n\n    const hand = 'FullHouse';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ threes[ 0 ] ],\n      pokerRankStrengthMap[ twos[ 0 ] ],\n    ];\n\n    return {\n      hand,\n      cards: sameCards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // flush\n  for ( const [ _suit, cardsSet ] of cardsBySuit.map ) {\n    if ( cardsSet.size > 4 ) {\n      const cards = sortPokerCardsByRank( Array.from( cardsSet ) );\n      cards.splice( 0, cards.length - 5 );\n\n      const hand = 'Flush';\n      const strength = [\n        pokerHandStrengthMap[ hand ],\n        ...cards\n          .concat()\n          .reverse()\n          .map( ( card ) => (\n            pokerRankStrengthMap[ card[ 0 ] as PokerRank ]\n          ) ),\n      ];\n\n      return {\n        hand,\n        cards: cards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n        strength,\n      };\n    }\n  }\n\n  // straight\n  if ( straightCards ) {\n    straightCards.splice( 0, straightCards.length - 5 );\n\n    const hand = 'Straight';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ straightCards[ 4 ][ 0 ] as PokerRank ],\n    ];\n\n    return {\n      hand,\n      cards: straightCards as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // three of a kind\n  if ( threes.length > 0 ) {\n    threes.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    threes.splice( 0, threes.length - 1 );\n\n    // Ah, Ad, Kc, 7s, 4s, Qc, As\n\n    const sameCards = Array.from( cardsByRank.get( threes[ 0 ] ) );\n    sameCards.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // Kc, 7s, 4s, Qc\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 2 );\n    // Qc, Kc\n\n    const hand = 'ThreeOfAKind';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ threes[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 1 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...sameCards );\n    sortPokerCardsByRank( cards_ );\n    // Qc, Kc, Ad, Ah, As\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // two pair\n  if ( twos.length > 1 ) {\n    twos.sort( ( a, b ) => pokerRankStrengthMap[ a ] - pokerRankStrengthMap[ b ] );\n    twos.splice( 0, twos.length - 2 );\n\n    // 4c, 8d, 7h, 4h, 8h, Jc, 2s\n\n    const pairs = Array.from( cardsByRank.get( twos[ 0 ] ) );\n    pairs.push( ...Array.from( cardsByRank.get( twos[ 1 ] ) ) );\n    pairs.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // 7h, Jc, 2s\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 1 );\n    // Jc\n\n    const hand = 'TwoPair';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ twos[ 1 ] ],\n      pokerRankStrengthMap[ twos[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...pairs );\n    sortPokerCardsByRank( cards_ );\n    // 4c, 4h, 8d, 8h, Jc\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // one pair\n  if ( twos.length > 0 ) {\n    // 3c, 5d, 8c, 8s, Ac, Qd, 7h\n\n    const pair = Array.from( cardsByRank.get( twos[ 0 ] ) );\n    pair.map( ( card ) => (\n      cards_.splice( cards_.indexOf( card ), 1 )\n    ) );\n    // 3c, 5d, Ac, Qd, 7h\n\n    sortPokerCardsByRank( cards_ ).splice( 0, cards_.length - 3 );\n    // 7h, Qd, Ac\n\n    const hand = 'OnePair';\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ twos[ 0 ] ],\n      pokerRankStrengthMap[ cards_[ 2 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 1 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    cards_.push( ...pair );\n    sortPokerCardsByRank( cards_ );\n    // 7h, 8c, 8s, Qd, Ac\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n\n  // high card\n  {\n    const hand = 'HighCard';\n\n    // 2h, 5c, 6c, 7s, Td, Ad, Kd\n\n    sortPokerCardsByRank( cards_ );\n    // 2h, 5c, 6c, 7s, Td, Kd, Ad\n\n    cards_.splice( 0, cards_.length - 5 );\n    // 6c, 7s, Td, Kd, Ad\n\n    const strength = [\n      pokerHandStrengthMap[ hand ],\n      pokerRankStrengthMap[ cards_[ 4 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 3 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 2 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 1 ][ 0 ] as PokerRank ],\n      pokerRankStrengthMap[ cards_[ 0 ][ 0 ] as PokerRank ],\n    ];\n\n    return {\n      hand,\n      cards: cards_ as [ PokerCard, PokerCard, PokerCard, PokerCard, PokerCard ],\n      strength,\n    };\n  }\n}\n", "import type { PokerHand } from './PokerHand';\n\nexport const pokerHandsByStrength: PokerHand[] = [\n  'HighCard',\n  'OnePair',\n  'TwoPair',\n  'ThreeOfAKind',\n  'Straight',\n  'Flush',\n  'FullHouse',\n  'FourOfAKind',\n  'StraightFlush',\n];\n", "/**\n * Retry given function for n times.\n *\n * See also: {@link retry}\n */\nexport async function asyncRetry<T>( func: () => Promise<T>, n: number ): Promise<T> {\n  return await func().catch( ( error ) => {\n    if ( n <= 1 ) {\n      throw error;\n    }\n\n    return asyncRetry( func, n - 1 );\n  } );\n}\n", "/**\n * Retry given function for n times.\n *\n * See also: {@link asyncRetry}\n */\nexport function retry<T>( func: () => T, n: number ): T {\n  try {\n    return func();\n  } catch ( error ) {\n    if ( n <= 1 ) {\n      throw error;\n    }\n\n    return retry( func, n - 1 );\n  }\n}\n", "import { STNICCCFrame } from './STNICCCFrame';\n\n/**\n * Ref: http://arsantica-online.com/st-niccc-competition/\n *\n * @param buffer The input ST-NICCC data\n */\nexport function parseSTNICCC( buffer: ArrayBuffer ): STNICCCFrame[] {\n  const frames: STNICCCFrame[] = [];\n\n  const array = new Uint8Array( buffer );\n\n  const palette = new Uint16Array( 16 );\n\n  let head = 0;\n\n  // when poly-descriptor says 0xfe\n  let shouldSkip = false;\n\n  // when poly-descriptor says 0xfd\n  let shouldEnd = false;\n\n  // > Every frame stores the following data:\n  for ( ;; ) {\n    // > 1 byte Flags Bit 0: Frame needs to clear the screen.\n    // > Bit 1: Frame contains palette data.\n    // > Bit 2: Frame is stored in indexed mode.\n    const flags = array[ head ++ ];\n    const needsClear = ( flags & 1 ) === 1;\n    const hasPalette = ( flags >> 1 & 1 ) === 1;\n    const indexedMode = ( flags >> 2 & 1 ) === 1;\n\n    // > If frame contains palette data\n    if ( hasPalette ) {\n      // > 1 word Bitmask\n      const bitmask = array[ head ++ ] << 8 | array[ head ++ ];\n\n      // > For every set bit in the Bitmask (0-15)\n      for ( let i = 0; i < 16; i ++ ) {\n        if ( bitmask >> ( 15 - i ) & 1 ) {\n          // > 1 word Color The color has to be copied into the palette at the reverse index of the actual bit,\n          // > because the bitmask is stored in reverse order.\n          // > In other words: If bit 15 of mask is set -> update color 0 of palette,\n          // > \u2026\n          // > if bit 0 of mask is set -> update color 15 of palette.\n\n          palette[ i ] = array[ head ++ ] << 8 | array[ head ++ ];\n        }\n      }\n    }\n\n    // > If frame is stored in indexed mode\n    if ( indexedMode ) {\n      // > 1 byte Number of vertices (0-255)\n      const nVertices = array[ head ++ ];\n\n      // > For every Vertex\n      // > {\n      // > 1 byte X-position\n      // > 1 byte Y-position\n      // > }\n      const vertices = array.subarray( head, head + 2 * nVertices );\n      head += 2 * nVertices;\n\n      const polygons: { colorIndex: number; indices: number[] }[] = [];\n\n      // > While (\u2026)\n      for ( ;; ) {\n        // > 1 byte Poly-descriptor Contains: hi-nibble - 4 bits color-index\n        // > lo-nibble - 4 bits number of polygon vertices\n        // >\n        // > Some special cases are encoded in the descriptor byte:\n        // > $ff = End of frame\n        // > $fe = End of frame and the stream skips to the next 64KB block\n        // > $fd = End of stream (we are done \\o/)\n        const descriptor = array[ head ++ ];\n\n        if ( descriptor === 0xff ) { // end of frame\n          break;\n\n        } else if ( descriptor === 0xfe ) { // end of frame + skip to the next 64KB\n          shouldSkip = true;\n          break;\n\n        } else if ( descriptor === 0xfd ) { // end of stream\n          shouldEnd = true;\n          break;\n\n        }\n\n        const colorIndex = descriptor >> 4 & 15;\n        const nIndices = descriptor & 15;\n\n        // > For every vertex of the polygon\n        // > {\n        // > 1 byte Vertex-id (0-255)\n        // > }\n        const indices = array.subarray( head, head + nIndices );\n        head += nIndices;\n\n        polygons.push( {\n          colorIndex,\n          indices: Array.from( indices ),\n        } );\n      }\n\n      frames.push( {\n        needsClear,\n        indexedMode,\n        palette: Array.from( palette ),\n        vertices: Array.from( vertices ),\n        polygons,\n      } );\n\n    // > Else if frame is stored in non-indexed mode\n    } else {\n      const polygons: { colorIndex: number; vertices: number[] }[] = [];\n\n      // > While (\u2026)\n      for ( ;; ) {\n        // > 1 byte Poly-descriptor (See indexed mode)\n        const descriptor = array[ head ++ ];\n\n        if ( descriptor === 0xff ) { // end of frame\n          break;\n\n        } else if ( descriptor === 0xfe ) { // end of frame + skip to the next 64KB\n          shouldSkip = true;\n          break;\n\n        } else if ( descriptor === 0xfd ) { // end of stream\n          shouldEnd = true;\n          break;\n\n        }\n\n        const colorIndex = descriptor >> 4 & 15;\n        const nVertices = descriptor & 15;\n\n        // > For every vertex of the polygon\n        // > {\n        // > 1 byte Vertex-id (0-255)\n        // > }\n        const vertices = array.subarray( head, head + 2 * nVertices );\n        head += 2 * nVertices;\n\n        polygons.push( {\n          colorIndex,\n          vertices: Array.from( vertices ),\n        } );\n      }\n\n      frames.push( {\n        needsClear,\n        indexedMode,\n        palette: Array.from( palette ),\n        polygons,\n      } );\n    }\n\n    if ( shouldSkip ) {\n      head = ( Math.floor( head / 0x10000 ) + 1 ) * 0x10000;\n      shouldSkip = false;\n    }\n\n    if ( shouldEnd ) {\n      break;\n    }\n  }\n\n  return frames;\n}\n", "import { STNICCCFrame } from './STNICCCFrame';\nimport { colorFromAtariST } from '../color/colorFromAtariST';\nimport { colorToHex } from '../color/colorToHex';\n\nexport function stnicccToSVG( frames: STNICCCFrame[], options: {\n  fps?: number;\n} = {} ): string {\n  const delta = 1.0 / ( options?.fps ?? 30.0 );\n\n  let svg = '<svg width=\"256\" height=\"200\" viewBox=\"0 0 256 200\" xmlns=\"http://www.w3.org/2000/svg\">';\n\n  let style = `g{visibility:hidden;animation-duration:${ ( delta * frames.length ).toFixed( 3 ) }s;animation-iteration-count:infinite;animation-name:frame}@keyframes frame{0%{visibility:visible}${ 200.0 / frames.length }%{visibility:hidden}}`;\n\n  frames.map( ( frame, iFrame ) => {\n    const { indexedMode, palette, polygons } = frame;\n\n    style += `#f${ iFrame }{animation-delay:${ ( delta * iFrame ).toFixed( 3 ) }s}`;\n\n    const paletteInHex = palette.map( ( stColor ) => {\n      const color = colorFromAtariST( stColor );\n      return colorToHex( color );\n    } );\n\n    let childrenStr = '<rect width=\"256\" height=\"200\" fill=\"#000\" />';\n\n    let currentColorIndex = -1;\n    let d = '';\n\n    if ( indexedMode ) {\n      const { vertices } = frame;\n\n      polygons.map( ( { colorIndex, indices } ) => {\n        if ( currentColorIndex !== colorIndex ) {\n          if ( currentColorIndex !== -1 ) {\n            const colorHex = paletteInHex[ currentColorIndex ];\n            childrenStr += `<path d=\"${ d }\" fill=\"${ colorHex }\" />`;\n          }\n\n          currentColorIndex = colorIndex;\n          d = '';\n        }\n\n        for ( let i = 0; i < indices.length; i ++ ) {\n          const index = indices[ i ];\n          const x = vertices[ 2 * index ];\n          const y = vertices[ 2 * index + 1 ];\n\n          d += i === 0\n            ? `M${ x },${ y }`\n            : `L${ x },${ y }`;\n        }\n      } );\n    } else {\n      polygons.map( ( { colorIndex, vertices } ) => {\n        if ( currentColorIndex !== colorIndex ) {\n          if ( currentColorIndex !== -1 ) {\n            const colorHex = paletteInHex[ currentColorIndex ];\n            childrenStr += `<path d=\"${ d }\" fill=\"${ colorHex }\" />`;\n          }\n\n          currentColorIndex = colorIndex;\n          d = '';\n        }\n\n        for ( let i = 0; i < vertices.length; i += 2 ) {\n          const x = vertices[ i ];\n          const y = vertices[ i + 1 ];\n\n          d += i === 0\n            ? `M${ x },${ y }`\n            : `L${ x },${ y }`;\n        }\n      } );\n    }\n\n    const colorHex = paletteInHex[ currentColorIndex ];\n    childrenStr += `<path d=\"${ d }\" fill=\"${ colorHex }\" />`;\n\n    svg += `<g id=\"f${ iFrame }\">${ childrenStr }</g>`;\n  } );\n\n  svg += `<style>${style}</style></svg>`;\n\n  return svg;\n}\n", "/**\n * The naive implementation of so-called SmoothDamp.\n * Pretty much the same as {@link CDS}, but it has a way easier parameter to tweak, {@link smoothTime}.\n *\n * Ref: Game Programming Gems 4, Chapter 1.10\n *\n * See: https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Mathf.cs#L308\n */\nexport class SmoothDamp {\n  public smoothTime = 1.0;\n  public velocity = 0.0;\n  public value = 0.0;\n  public target = 0.0;\n\n  public update( deltaTime: number ): number {\n    const omega = 2.0 / this.smoothTime;\n    const x = omega * deltaTime;\n    const exp = 1.0 / ( 1.0 + x + 0.48 * x * x + 0.235 * x * x * x );\n    const delta = this.value - this.target;\n    const temp = ( this.velocity + omega * delta ) * deltaTime;\n    this.velocity = ( this.velocity - omega * temp ) * exp;\n    this.value = this.target + ( delta + temp ) * exp;\n    return this.value;\n  }\n}\n", "/**\n * Useful for swap buffer\n */\nexport class Swap<T> {\n  public i: T;\n  public o: T;\n\n  public constructor( a: T, b: T ) {\n    this.i = a;\n    this.o = b;\n  }\n\n  public swap(): void {\n    const i = this.i;\n    this.i = this.o;\n    this.o = i;\n  }\n}\n", "import { HistoryMeanCalculator } from '../HistoryMeanCalculator/HistoryMeanCalculator';\n\nexport class TapTempo {\n  private __bpm = 0.0;\n  private __lastTap = 0.0;\n  private __lastBeat = 0.0;\n  private __lastTime = 0.0;\n  private __calc: HistoryMeanCalculator = new HistoryMeanCalculator( 16 );\n\n  public get beatDuration(): number {\n    return 60.0 / this.__bpm;\n  }\n\n  public get bpm(): number {\n    return this.__bpm;\n  }\n\n  public set bpm( bpm: number ) {\n    this.__lastBeat = this.beat;\n    this.__lastTime = performance.now();\n    this.__bpm = bpm;\n  }\n\n  public get beat(): number {\n    return this.__lastBeat + ( performance.now() - this.__lastTime ) * 0.001 / this.beatDuration;\n  }\n\n  public reset(): void {\n    this.__calc.reset();\n  }\n\n  public nudge( amount: number ): void {\n    this.__lastBeat = this.beat + amount;\n    this.__lastTime = performance.now();\n  }\n\n  public tap(): void {\n    const now = performance.now();\n    const delta = ( now - this.__lastTap ) * 0.001;\n\n    if ( 2.0 < delta ) {\n      this.reset();\n    } else {\n      this.__calc.push( delta );\n      this.__bpm = 60.0 / ( this.__calc.mean );\n    }\n\n    this.__lastTap = now;\n    this.__lastTime = now;\n    this.__lastBeat = 0.0;\n  }\n}\n", "import { arraySerial } from '../array';\n\n/**\n * Parse a polyphonic tinyseq buffer.\n *\n * Returns [ time, offTime, note, reserved, time, offTime, note, reserved, ... ]\n */\nexport function createTinyseqPolyReader(\n  buffer: Uint8Array,\n  options: {\n    poly?: number,\n    blockSize?: number,\n    sampleRate?: number,\n    stepsPerSecond?: number,\n  } = {},\n): () => Float32Array[] {\n  const poly = options.poly ?? 8;\n  const blockSize = options.blockSize ?? 128;\n  const sampleRate = options.sampleRate ?? 48000;\n  const stepsPerSecond = options.stepsPerSecond ?? 1.0;\n\n  let samples = 0;\n  let pos = 0;\n  let note: number;\n  const notes = arraySerial( poly ).fill( -1 );\n  const notesTime = arraySerial( poly ).fill( -Infinity );\n  const notesOffTime = arraySerial( poly ).fill( -Infinity );\n  let nextStep = 0;\n\n  return () => {\n    const ret = arraySerial( poly ).map( () => new Float32Array( 4 * blockSize ) );\n\n    arraySerial( blockSize ).map( ( iSample ) => {\n      const t = samples / sampleRate;\n      const s = t * stepsPerSecond;\n\n      if ( s >= nextStep ) {\n        const eventNote = buffer[ pos ];\n        const eventDeltaStep = buffer[ pos + 1 ];\n\n        note = ( ( pos === 0 ? 60 : note ) + eventNote ) & 127;\n\n        // find same note\n        let iPoly = notes.indexOf( note );\n\n        // find earliest note off\n        let tEarliest = Infinity;\n\n        if ( iPoly === -1 ) {\n          notesTime.map( ( tOn, jPoly ) => {\n            const tOff = notesOffTime[ jPoly ];\n            if ( tOn <= tOff ) {\n              if ( tOff < tEarliest ) {\n                iPoly = jPoly;\n                tEarliest = tOff;\n              }\n            }\n          } );\n        }\n\n        // find earliest note on\n        if ( iPoly === -1 ) {\n          notesTime.map( ( tOn, jPoly ) => {\n            if ( tOn < tEarliest ) {\n              iPoly = jPoly;\n              tEarliest = tOn;\n            }\n          } );\n        }\n\n        notes[ iPoly ] = note;\n\n        if ( eventNote & 128 ) {\n          if ( notesOffTime[ iPoly ] < notesTime[ iPoly ] ) {\n            notesOffTime[ iPoly ] = t;\n          }\n        } else {\n          if ( notesOffTime[ iPoly ] >= notesTime[ iPoly ] ) {\n            notesTime[ iPoly ] = t;\n          }\n        }\n\n        nextStep += eventDeltaStep;\n\n        pos = ( pos + 2 ) % buffer.length;\n      }\n\n      samples ++;\n\n      arraySerial( poly ).map( ( iPoly ) => {\n        const noteTime = notesTime[ iPoly ];\n        const noteOffTime = notesOffTime[ iPoly ];\n\n        ret[ iPoly ][ 4 * iSample + 0 ] = t - noteTime; // time\n        ret[ iPoly ][ 4 * iSample + 1 ] = noteOffTime < noteTime ? 0.0 : t - noteOffTime; // offTime\n        ret[ iPoly ][ 4 * iSample + 2 ] = notes[ iPoly ]; // note\n        ret[ iPoly ][ 4 * iSample + 3 ] = 0.0; // reserved\n      } );\n    } );\n\n    return ret;\n  };\n}\n", "import { arraySerial } from '../array';\n\n/**\n * Parse a tinyseq buffer.\n *\n * Returns [ time, offTime, note, reserved, time, offTime, note, reserved, ... ]\n */\nexport function createTinyseqReader(\n  buffer: Uint8Array,\n  options: {\n    blockSize?: number,\n    sampleRate?: number,\n    stepsPerSecond?: number,\n  } = {},\n): () => Float32Array {\n  const blockSize = options.blockSize ?? 128;\n  const sampleRate = options.sampleRate ?? 48000;\n  const stepsPerSecond = options.stepsPerSecond ?? 960.0;\n\n  let samples = 0;\n  let pos = 0;\n  let note: number;\n  let noteTime = -Infinity;\n  let noteOffTime = -Infinity;\n  let nextStep = 0;\n\n  return () => {\n    return new Float32Array( arraySerial( blockSize ).map( () => {\n      const t = samples / sampleRate;\n      const s = t * stepsPerSecond;\n\n      if ( s >= nextStep ) {\n        const eventNote = buffer[ pos ];\n        const eventDeltaStep = buffer[ pos + 1 ];\n\n        note = ( ( pos === 0 ? 60 : note ) + eventNote ) & 127;\n        if ( eventNote & 128 ) {\n          if ( noteOffTime < noteTime ) {\n            noteOffTime = t;\n          }\n        } else {\n          if ( noteOffTime >= noteTime ) {\n            noteTime = t;\n          }\n        }\n\n        nextStep += eventDeltaStep;\n\n        pos = ( pos + 2 ) % buffer.length;\n      }\n\n      samples ++;\n\n      return [\n        t - noteTime, // time\n        noteOffTime < noteTime ? 0.0 : t - noteOffTime, // offTime\n        note, // note\n        0.0, // reserved\n      ];\n    } ).flat() );\n  };\n}\n", "import { MidiParseResult } from '../midi';\nimport { arraySerial } from '../array';\n\n/**\n * Convert the parsed midi result to a tinyseq binary.\n *\n * See: {@link midiParse}\n *\n * @param midi The parsed midi result\n * @param track The index of the midi track you want to convert\n * @param tickMultiplier Multiply this value to tick\n * @returns A tinyseq binary\n */\nexport function tinyseqFromMidiParseResult(\n  midi: MidiParseResult,\n  { track, tickMultiplier }: {\n    track?: number,\n    tickMultiplier?: number,\n  } = {},\n): Uint8Array {\n  const data: number[] = [];\n  let lastNote = 60;\n  let delta = 0;\n\n  const trackEvents = midi[ 1 ][ track ?? 0.0 ];\n\n  // [ delta, midi event, note, vel ][] -> [ onoff (0 or 128) + deltaNote, delta, ... ]\n  // [ [ 4, 144, 60, 100 ], [ 4, 128, 60, 100 ] ] -> [ 128, 4, 0, 4, 128, 0 ]\n\n  arraySerial( trackEvents.length + 1 ).map( ( i ) => {\n    delta += ( trackEvents[ i ]?.[ 0 ] ?? 0 ) * ( tickMultiplier ?? 1.0 );\n\n    if ( delta === 0 && i === 0 ) { return; } // ignore if it's the first event and delta is 0\n\n    const evMsg = trackEvents[ i - 1 ]?.[ 1 ] ?? 128;\n    const evNote = trackEvents[ i - 1 ]?.[ 2 ] ?? 60;\n\n    if ( evMsg >= 160 ) { return; } // ignore if the msg is not a note event\n\n    const noteDelta = ( evNote - lastNote + 128 ) & 127;\n    lastNote = evNote;\n    const onoff = evMsg < 144 ? 128 : 0; // 0 if on (144 - 159), 128 if off (128 - 143)\n\n    // probably 240 is more efficient than 256 since the division in most of midi files are 480 or 960\n    let deltaConsume = Math.floor( Math.min( delta, 240 ) );\n    data.push( noteDelta + onoff, deltaConsume );\n    delta -= deltaConsume;\n\n    while ( delta >= 1 ) {\n      deltaConsume = Math.floor( Math.min( delta, 240 ) );\n      data.push( onoff, deltaConsume );\n      delta -= deltaConsume;\n    }\n  } );\n\n  return new Uint8Array( data );\n}\n", "export class Xorshift {\n  public seed: number;\n\n  public constructor( seed?: number ) {\n    this.seed = seed || 1;\n  }\n\n  public gen( seed?: number ): number {\n    if ( seed ) {\n      this.seed = seed;\n    }\n\n    this.seed = this.seed ^ ( this.seed << 13 );\n    this.seed = this.seed ^ ( this.seed >>> 17 );\n    this.seed = this.seed ^ ( this.seed << 5 );\n    return this.seed / Math.pow( 2, 32 ) + 0.5;\n  }\n\n  public set( seed?: number ): void {\n    this.seed = seed || this.seed || 1;\n  }\n}\n\nexport default Xorshift;\n", "import { linearstep } from '../math/utils';\n\n/**\n * https://twitter.com/yugop\n *\n * @param text The input text\n * @param phase The value between 0.0 and 1.0\n * @param randomRatio The nerd value\n */\nexport function getYugopText( text: string, phase: number, randomRatio = 0.5 ): string {\n  if ( phase >= 1.0 ) { return text; }\n  if ( phase < 0.0 ) { return ''; }\n\n  /*\n   * ------=====\n   * .------====\n   * ..------===\n   * ...------==\n   * ....------=\n   * ^     ^   ^\n   * |     |   |\n   * |     |   phase is 1.0\n   * |     phase is randomRatio\n   * phase is 0.0\n   */\n\n  const displayTween = linearstep( 0.0, 1.0 - randomRatio, phase );\n  const fixTween = linearstep( randomRatio, 1.0, phase );\n\n  const displayLength = 1.0 + Math.floor( displayTween * ( text.length - 1 ) );\n  const fixLength = phase < randomRatio ? 0 : 1.0 + Math.floor( fixTween * ( text.length - 1 ) );\n  const randomLength = displayLength - fixLength;\n\n  const randomStr = [ ...Array( randomLength ) ]\n    .map( () => String.fromCharCode( 33 + Math.floor( 93 * Math.random() ) ) )\n    .join( '' );\n\n  return text.substring( 0, fixLength ) + randomStr;\n}\n", "export class BinaryHeap<T> {\n  public readonly array: T[];\n  public readonly elementIndexMap: Map<T, number>;\n  public comparator: ( a: T, b: T ) => number;\n\n  public static defaultComparator( a: any, b: any ): number {\n    const aStr = `${ a }`;\n    const bStr = `${ b }`;\n\n    if ( aStr > bStr ) {\n      return 1;\n    } else if ( aStr < bStr ) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n\n  public get length(): number {\n    return this.array.length;\n  }\n\n  public get isEmpty(): boolean {\n    return this.array.length === 0;\n  }\n\n  public get root(): T {\n    return this.array[ 0 ];\n  }\n\n  public constructor( init?: T[], comparator?: ( a: T, b: T ) => number ) {\n    this.array = [];\n    this.elementIndexMap = new Map();\n    this.comparator = comparator ?? BinaryHeap.defaultComparator;\n\n    if ( init != null ) {\n      for ( const el of init ) {\n        this.push( el );\n      }\n    }\n  }\n\n  public push( ...elements: T[] ): void {\n    elements.map( ( el ) => {\n      const i = this.length;\n      this.array.push( el );\n      this.elementIndexMap.set( el, i );\n      this.__up( i, el );\n    } );\n  }\n\n  public pop(): T | null {\n    if ( this.isEmpty ) {\n      return null;\n    }\n\n    const el = this.array[ 0 ];\n    this.elementIndexMap.delete( el );\n\n    if ( this.length === 1 ) {\n      this.array.splice( 0 );\n    } else {\n      const rep = this.array.pop();\n      this.__down( 0, rep! );\n    }\n\n    return el;\n  }\n\n  public delete( i: number ): boolean {\n    this.elementIndexMap.delete( this.array[ i ] );\n\n    const rep = this.array.pop();\n    if ( rep != null ) {\n      i = this.__up( i, rep );\n      i = this.__down( i, rep );\n    }\n\n    return true;\n  }\n\n  public replace( i: number, rep: T ): number | null {\n    if ( i != null ) {\n      this.elementIndexMap.delete( this.array[ i ] );\n\n      i = this.__up( i, rep );\n      i = this.__down( i, rep );\n    }\n\n    return i ?? null;\n  }\n\n  private __up( i: number, el: T ): number {\n    let ic = i;\n\n    while ( ic !== 0 ) {\n      const ip = ( ic - 1 ) >> 1;\n\n      const p = this.array[ ip ];\n      if ( this.comparator( el, p ) < 0 ) {\n        this.array[ ic ] = p;\n        this.elementIndexMap.set( p, ic );\n        ic = ip;\n      } else {\n        break;\n      }\n    }\n\n    this.array[ ic ] = el;\n    this.elementIndexMap.set( el, ic );\n    return ic;\n  }\n\n  private __down( i: number, el: T ): number {\n    let ip = i;\n\n    while ( ( ip << 1 ) + 1 < this.length ) {\n      const ic1 = ( ip << 1 ) + 1;\n      const ic2 = ( ip << 1 ) + 2;\n\n      if ( ic2 < this.length ) {\n        const c1 = this.array[ ic1 ];\n        const c2 = this.array[ ic2 ];\n\n        const pickLeft = this.comparator( c1, c2 ) < 0;\n        const c = pickLeft ? c1 : c2;\n        const ic = pickLeft ? ic1 : ic2;\n\n        if ( this.comparator( c, el ) < 0 ) {\n          this.array[ ip ] = c;\n          this.elementIndexMap.set( c, ip );\n          ip = ic;\n        } else {\n          break;\n        }\n      } else if ( this.comparator( this.array[ ic1 ], el ) < 0 ) {\n        this.array[ ip ] = this.array[ ic1 ];\n        this.elementIndexMap.set( this.array[ ip ], ip );\n        ip = ic1;\n      } else {\n        break;\n      }\n    }\n\n    this.array[ ip ] = el;\n    this.elementIndexMap.set( el, ip );\n    return ip;\n  }\n}\n", "/**\n * Make the given function a debounced one.\n *\n * @example\n * ```ts\n * const func = debounce( 100, () => {\n *   // some expensive procedure\n * } );\n *\n * func();\n * func();\n * func();\n * ```\n */\nexport function debounce(\n  func: () => void,\n  timeoutMs: number,\n): () => void {\n  let id: ReturnType<typeof setTimeout> | null | undefined;\n\n  return () => {\n    if ( id ) {\n      clearTimeout( id );\n    }\n\n    id = setTimeout( () => {\n      func();\n      id = null;\n    }, timeoutMs );\n  };\n}\n", "/**\n * An utility type definition to use along with {@link notifyObservers}.\n */\nexport type Observer<TEvent = void> = ( event: TEvent ) => void;\n\n/**\n * A bare function to notify observers.\n * The incredibly cheap implementation of the observer pattern.\n *\n * Use along with the utility type definition {@link Observer}.\n *\n * @example\n * ```ts\n * const observers = new Set<Observer<string>>();\n *\n * observers.add( ( text ) => console.log( text ) );\n * observers.add( ( text ) => alert( text ) );\n *\n * notifyObservers( observers, 'wenis' );\n * ```\n *\n * @param observers The iterator of observers\n * @param param The param you want to give to observers\n */\nexport function notifyObservers( observers: Iterable<Observer<void>> ): void;\nexport function notifyObservers<T>( observers: Iterable<Observer<T>>, param: T ): void;\nexport function notifyObservers( observers: Iterable<Observer<any>>, param?: any ): void {\n  for ( const observer of observers ) {\n    observer( param );\n  }\n}\n", "/**\n * Make the given function a throttled one.\n *\n * @example\n * ```ts\n * const func = throttle( 100, () => {\n *   // some expensive procedure\n * } );\n *\n * func();\n * func();\n * func();\n * ```\n */\nexport function throttle(\n  func: () => void,\n  rateMs: number,\n): () => void {\n  let waiting = false;\n  let lastTime = -Infinity;\n\n  return () => {\n    const now = Date.now();\n    const untilNext = Math.max( 0, lastTime + rateMs - now );\n\n    if ( !waiting ) {\n      setTimeout( () => {\n        lastTime = Date.now();\n        func();\n        waiting = false;\n      }, untilNext );\n      waiting = true;\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
